{"title": "微信小程序开发中各种跳转方式的区别 ", "author": "Rolan", "time": "2019-10-21 00:48", "abstract": "wx.navigateTo、wx.redirectTo、wx.reLaunch、wx.switchTab和wx.navigateBack有什么区别呢？wx.navigateTo：用于保留当前页面、跳转到应用内的某个页面，使用 wx.navigateBack可以返回到原页面。对于页面不是特别多 ...", "content": "wx.navigateTo、wx.redirectTo、wx.reLaunch、wx.switchTab和wx.navigateBack有什么区别呢？wx.navigateTo：用于保留当前页面、跳转到应用内的某个页面，使用 wx.navigateBack可以返回到原页面。对于页面不是特别多的小程序，通常推荐使用 wx.navigateTo进行跳转， 以便返回原页面，以提高加载速度。当页面特别多时，则不推荐使用。wx.redirectTo：当页面过多时，被保留页面会挤占微信分配给小程序的内存，或是达到微信所限制的 5 层页面栈。这时应该考虑选择 wx.redirectTo。wx.redirectTo()用于关闭当前页面，跳转到应用内的某个页面。这样的跳转，可以避免跳转前页面占据运行内存，但返回时页面需要重新加载，增加了返回页面的显示时间。wx.reLaunch：wx.reLaunch()与 wx.redirectTo()的用途基本相同， 只是 wx.reLaunch()先关闭了内存中所有保留的页面，再跳转到目标页面。wx.switchTab：对于跳转到 tab bar 的页面，最好选择 wx.switchTab()，它会先关闭所有非 tab bar 的页面。其次，也可以选择 wx.reLaunch()，它也能实现从非 tab bar 跳转到 tab bar，或在 tab bar 间跳转，效果等同 wx.switchTab()。使用其他跳转 API 来跳转到 tab bar，则会跳转失败。wx.navigateBack：用于关闭当前页面，并返回上一页面或多级页面。开发者可通过 getCurrentPages() 获取当前的页面栈，决定需要返回几层。这个 API 需要填写的参数只有 delta，表示要返回的页面数。若 delta 的取值大于现有可返回页面数时，则返回到用户进入小程序的第一个页面。当不填写 delta 的值时，就默认其为 1（注意，默认并非取 0），即返回上一页面。本文来自木庄网络博客> wx.navigateTo、wx.redirectTo、wx.reLaunch、wx.switchTab和wx.navigateBack的区别"}
{"title": "借助小程序·云开发制作校园导览小程序丨实战 ", "author": "Rolan", "time": "2019-10-14 00:21", "abstract": "背景当你刚上大学的时候，要想不迷失校园，除了依靠不怎么可靠的路边标识外，总会收到那么一张卡通绘制的校园地图：这种静态图片可以让我们快速地了解到所需的地理位置信息，但使用和思考过后，会发现以下问题：地理 ...", "content": "背景当你刚上大学的时候，要想不迷失校园，除了依靠不怎么可靠的路边标识外，总会收到那么一张卡通绘制的校园地图：这种静态图片可以让我们快速地了解到所需的地理位置信息，但使用和思考过后，会发现以下问题：地理位置信息粒度高，而同一个地点通常具有多个服务功能和别名。地理位置信息变更导致地图信息过时。一旦服务网点迁移或更名，需要重绘地图，带来一定的延迟和信息滞后。入口较深。存储在手机上的地图并不是那么好找，尤其是随着时间的推移。无法准确的定位当前所处位置，需要寻找参照物，这是静态地图致命的缺点。缺乏更为详细的地点介绍，只能在有限的画面里堆积内容。为此，我设计了一款校园导览应用，用当下流行的微信小程序结合云开发能力，低成本高效能地解决了以上问题。此外，我还根据对市面上的同类应用进行设计上的研究，在界面和交互设计上做功夫。下面我会进行简短的介绍。南苑导览南苑导览是一款由学生独立开发的以地图为载体，提供 中山大学南方学院 （南苑）具体地点的位置信息、导航、校园历史及文化介绍的小程序。旨在解决校园导航标识不到位、地图形式低效单一、信息设计不够好等问题，为来南苑新人和游客提供更加完美的出行体验。<div align=center>仅需修改地图配置文件，即可适配任意场景（校园、景区）的小程序个性化地图定制。技术栈：原生小程序 + TypeScript + gulp + vantUI + 云开发能力2019 微信小程序高校大赛 · 华南赛区二等奖</div>南苑导览 · 开发config 配置├─ src\r\n├─── config\r\n├───── index.ts // 入口\r\n├───── cloud.ts // 云开发相关配置\r\n├───── info.ts // 应用介绍信息\r\n├───── markerStyle.ts // 地图marker样式\r\n├───── panorama.ts // 第三方全景地图配置（个人类型无webview权限，默认关闭）\r\n└───── secret.ts // 腾讯地图key等敏感信息（可选）使用云数据库// markers表 数据格式\r\n{\r\n  _id: \"5ce8fe1c29c7a8581bc1e989\",  // id，云数据库录入upsert更新用\r\n  type: \"生活服务\",   // 场景名称\r\n  icon: \"shfw\",     // marker默认图标，为场景名称拼音缩写\r\n  scale: 15.0,   // 场景在地图上的缩放值，可选。已废弃，用includePoints代替\r\n  position: 0, // 指定在各个场景中的排列顺序\r\n  data: [   // 该场景下的地点markers\r\n    {\r\n      name: \"孙中山铜像\",   // 地点名称\r\n      short_name: \"铜像\", // 名称缩写\r\n      desc: \"中山铜像...\", // 描述信息\r\n      logo: \"tx\",   // 地点logo，缩写拼音, 如作各院系logo展示\r\n      icon: \"tx@2\",   // 自定义marker图标，“@”后数字为图标相较于默认图标的缩放值\r\n      images: 3,  // 图片数量，作云存储拼接路径用（cloud://cloudRoot/1教/n.jpg）\r\n      panorama: 0,  // 全景场景id\r\n      latitude: \"23.635875\",  // 经度\r\n      longitude: \"113.678965\",  // 纬度\r\n      contact: { phone: \"020-123456\", address: \"出门左转\" }   // 联系方式\r\n    }\r\n  ]\r\n}使用 excel 进行数据维护，通过 python pandas 进行数据清洗，使用 jsonlines 库输出符合云数据库的 JSON Lines 格式文件，以 upsert 形式导入数据库。数据更新流程如下：[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-9Kzq570X-1570761839095)( https://656e-enanyuan-6db383-... ]加载并清洗数据使用 request 或云数据库进行异步数据请求时。由于 app.js 中的 onLaunch 和首页 index 的 onLoad 的执行顺序不是固定的，所以如果首页有基于 app.js 请求的数据时要注意生命周期的问题。// index\r\nasync loadMarkers() {\r\n  let markers;\r\n  if (app.globalData.config.debug) {\r\n    // 本地\r\n    markers = mockMarkers;\r\n  } else {\r\n    // 云\r\n    await wx.cloud\r\n      .callFunction({\r\n        name: \"loadMarkers\"\r\n      })\r\n      .then((res: any) => {\r\n        markers = res.result.data;\r\n      });\r\n  }\r\n  app.globalData.markers = markers;\r\n}\r\n\r\nclearMarkers(markers: any[]) {\r\n  let num = 0;  // 每个marker都要有一个id\r\n  for (const i of markers) {\r\n    for (const j of i.data) {\r\n      j.id = num;\r\n      num += 1;\r\n      j.iconPath = `/assets/images/markers/${j.icon ? j.icon : i.icon}.png`;\r\n\r\n      ...\r\n\r\n      // 自定义气泡样式\r\n      j.callout = Object.assign(\r\n        { content: j.short_name ? j.short_name : j.name },\r\n        app.globalData.config.markerStyle.calloutStyle\r\n      );\r\n    }\r\n  }\r\n  return markers;\r\n}巧用 MapContext你不需要去手动地为每个场景设置 scale，用 includePoints 即可让地图视野自动覆盖到当前所有 POI。你也不需要去手动地去获取权限设置用户位置，用 moveToLocation 即可轻松定位。// index\r\nonReady() {\r\n  this.setData!({\r\n    mapContext: wx.createMapContext(\"map\")\r\n  });\r\n}\r\n\r\nincludePoints(padding: number) {\r\n  this.data.mapContext.includePoints({\r\n    padding: [padding, padding, padding, padding],\r\n    points: this.data.markers\r\n  });\r\n}\r\n\r\nlocate() {\r\n  this.data.mapContext.moveToLocation();\r\n}使用云存储管理图片添加新图片时，直接修改 images 字段即可，文件夹目录为地点名称。<!-- 地点详情页 轮播图 -->\r\n<swiper\r\n  indicator-dots=\"{{imgUrls.length > 1}}\"\r\n  autoplay=\"{{true}}\"\r\n  interval=\"3000\"\r\n  duration=\"1000\"\r\n>\r\n  <block wx:for=\"{{imgUrls}}\" wx:key=\"{{index}}\">\r\n    <swiper-item>\r\n      <image\r\n        src=\"{{item}}\"\r\n        class=\"slide\"\r\n        data-id=\"{{index}}\"\r\n        bindtap=\"previewImage\"\r\n      />\r\n    </swiper-item>\r\n  </block>\r\n</swiper>for (let i = 0; i < marker.images; i++) {\r\n  imgUrls.push(\r\n    this.data.cloudRoot +\r\n      \"images/\" +\r\n      (marker.short_name || marker.name) +\r\n      \"/\" +\r\n      i +\r\n      \".jpg\"\r\n  );\r\n}南苑导览 · 设计如果你在微信上搜索「导览」二字，看到的小程序大多都是一个模板，页面层级深，界面拥挤，列表式的信息展示并不符合我们日常使用地图 APP 的经验。为此，我做出了多项改良：[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-j76bV81T-1570761839095)( https://656e-enanyuan-6db383-... ]更好的视野 - 自定义导航栏与侧边栏因为只有特定的页面需要使用自定义导航栏，所以只需要设置页面级的 config：\"navigationStyle\": \"custom\"接下来获取胶囊按钮位置信息：bounding: wx.getMenuButtonBoundingClientRect();[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-XoDA3u2I-1570761839096)( https://656e-enanyuan-6db383-... ]动态地设置样式：<!-- SIDE MENU -->\r\n<view\r\n  class=\"sidebar\"\r\n  hidden=\"{{toggleRoutes}}\"\r\n  style=\"top:{{bounding.height + bounding.top + 10}}px\"\r\n>\r\n  ...\r\n</view>FAB 与侧边栏设计把最主要的定位、搜索和路线推荐功能在视觉上成为整体，通过点击 FAB 弹出菜单选项。侧边栏的地点场景菜单设计为下拉滚动，注意使用半遮设计来提醒用户滚动。同时，为了让界面更加精简，侧边菜单会在点击 FAB（Float Action Button）和母按钮时 toggle 显示与隐藏。[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-SP3GrjOr-1570761839096)( https://656e-enanyuan-6db383-... ]用点击代替滚动 - scroll-into-view在路线面板和搜索页中，使用到了 scroll-view 组件，利用其 scroll-into-view 特性，实现点击代替滚动的操作，同时也能起到提醒后置选项的作用。[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-o18t46ea-1570761839097)( https://656e-enanyuan-6db383-... ]windowWidth: wx.getSystemInfoSync().screenWidth;<scroll-view class=\"route\" scroll-x scroll-into-view=\"{{focusPointId}}\">\r\n  <view\r\n    class=\"points\"\r\n    style=\"width:{{routes[routeIndex].count * 140 < windowWidth ? windowWidth : routes[routeIndex].count * 140}}rpx;\"\r\n  >\r\n    ...\r\n  </view>\r\n</scroll-view>更好的视角 - 全景功能结合 web-view 和全景服务平台，可以为一款地图导览应用增色不少。总结云开发让小程序开发者无需搭建服务器，使用平台提供的 API 即可快速地进行业务开发、上线和迭代，免费的基础版完全可以满足中小应用的需求。「南苑导览」借助腾讯云开发能力，上线以来，帮助到了许许多多的新生和来客，实现了产品价值。最后，期望官方早日开放自定义地图底图能力，让开发者能够个性化地图，探索出更多的应用场景！源码地址https://github.com/TencentCloudBase/Good-practice-tutorial-recommended"}
{"title": "百度小程序与微信小程序全面对比 ", "author": "Rolan", "time": "2019-10-14 00:38", "abstract": "百度小程序已出来一段时间了，本文分享我在开发过程中遇到的一些百度小程序与微信小程序的差别。帮助你快速转换微信小程序到百度小程序。文档地址：https://smartprogram.baidu.com/docs/develop/tutorial/codedir/ ...", "content": "百度小程序已出来一段时间了，本文分享我在开发过程中遇到的一些百度小程序与微信小程序的差别。帮助你快速转换微信小程序到百度小程序。文档地址：https://smartprogram.baidu.com/docs/develop/tutorial/codedir/，有遇到问题的可以去百度小程序社区提问：https://smartprogram.baidu.com/forum/（需要登录并且有appid）。本文分享一些百度小程序与微信小程序的差别。百度小程序组件hidden属性区别虽然百度小程序没提到这个属性，但我测试发现它在本地上和真机上都是支持的。但跟微信还是有一点区别：js:\r\n\r\ndata: {\r\n\tflag:'123'\r\n}\r\n\r\nxml:\r\n<view hidden=\"true\">1</view>\r\n<view hidden=\"false\">2</view>\r\n<view hidden=\"!false\">3</view>\r\n<view hidden=\"{{false}}\">4</view>\r\n<view hidden=\"!flag\">5</view>\r\n<view hidden=\"flag\">6</view>\r\n<view hidden=\"{{flag}}\">7</view>\r\n<view hidden=\"{{!flag}}\">8</view>\r\n<view hidden=\"{{!!flag}}\">9</view>\r\n<view hidden=\"\">10</view>百度小程序输出：248微信输出：4810百度：当hidden的值为flase，或者插值{{false}}为flase时，百度组件不会隐藏。其它情况，不管是true或者是空，或者其它值，不为false，或者计算出来的值不为flase，都会被隐藏。微信：当这个hidden属性为空或者插值{{false}}为false，才不会隐藏。有一种特殊情况就是直接赋值它为hidden=\"false\"，这里的false不被当做布尔值，所以它也被隐藏。结论：从上面这两个之中我们可以看到 4 和 8 两者都有，那我们做的时候只需要保证 hidden 的值为插值形式，并且插值的结果是布尔值，那两者就能得到一致的表现。js文件命名空间wx.替换为swan.wx.request() -> swan.request()\r\nwx.showModal() -> swan.showModal()\r\nwx.canIuse() -> swan.canIuse()\r\n……\r\nswan文件整体替换wx:到s-主要有两个地方：1.条件判断wx:if -> s-if\r\n2.列表循环wx:for -> s-for\r\nwx:for-item -> s-for-item\r\nwx:key -> s-key\r\n这里还有3点跟微信使用起来有点区别1.for循环里面，百度是不支持跟if放在同一条语句里面。我们可以通过增加一个block来判断条件2.条件判断百度是没有使用插值计算。这是微信的：<view wx:if=\"{{condition}}\"> True </view>\r\n这是百度的：<view s-if=\"condition\"> True </view>\r\n3.组件中的3元运算符，不支持 <= 判断，猜测可能是bug，可能是里面使用了正则判断。<view>{{ 1 <= 2 ? 'yes' : 'no' }}</view>\r\n解析出来的内容为：<view>true<=\"\" view=\"\"></=></view>\r\n解决方法是改成 >=，或者<<view>{{ 2 >= 1 ? 'yes' : 'no' }}</view>\r\n模板1.声明需要使用的模板，data 是所需要传入到模板的值，当它是对象时，对象字面量是三个大括号包裹，微信是{{}}。<!-- template-demo.swan-->\r\n<template name=\"person-card\">\r\n    <view>\r\n        <text>位置: {{pos}}</text>\r\n        <text>姓名: {{name}}</text>\r\n    </view>\r\n</template>\r\n\r\n<!-- template-demo.swan-->\r\n<template is=\"person-card\" data=\"{{{person}}}\" />\r\n\r\n// template-demo.js\r\nPage({\r\n    data: {\r\n        person: {name: 'Lebron James', pos: 'SF', age: 33}\r\n    }\r\n});\r\n2.不支持动态调用<template name=\"tid-1\">\r\n    <view>1</view>\r\n    <view>{{index}}:{{msg}}</view>\r\n</template>\r\n<template name=\"tid-2\">\r\n    <view>2</view>\r\n    <view>{{index}}:{{msg}}</view>\r\n</template>\r\n当我需要根据tid值来调用某个模板时，例如tid=1时，使用下面的方法调用<template is=\"tid-{{tid}}\" data=\"{{{...item}}}\"/>\r\n\r\nPage({\r\n    data: {\r\n        tid:1\r\n    }\r\n});\r\n上面这种获取不了template tid-1的内容。我们可以通过条件判断来调用模板：<block s-if=\"{{ tid == 1}}\"><template is=\"template-1\" data=\"{{{...item}}}\" /></block>\r\nPage函数不要使用getData()由于我之前的页面中获取请求时用的是这个函数，然后我发现百度小程序里面这个函数在onload中无法执行到。另外就是如果直接点击执行这个函数，会报错。页面传递参数option，最好加上enCodeURIComponent()我之前的一个微信小程序传递url时，参数没有格式化，直接传递后，在百度小程序中会发现接收不完整，例如：http://xsps.pchouse.com.cn/ 转化为 http:/xsps.pchouse.com.cn。swan.createSelectorQuery()这个API要在页面DOM 加载完毕后执行，才能获取到具体的值，如果你直接在onload或者request 的success 里面setData后获取值，同样获取不到内容，可以在onReady里面获取到。有一种做法就是加一个定时器，在2秒后获取，或者改为当需要的时候才开始获取。不要使用HTML标签在百度小程序中，使用了div/ul/li等HTML标签，调试swan tab时，标签会被过滤掉。<div class=\"list\">\r\n\t<ul>\r\n\t\t<li bindtap=\"test\">测试</li>\r\n\t\t<li>测试</li>\r\n\t\t<li>测试</li>\r\n\t</ul>\r\n</div>\r\n\r\n.list ul{font-size:18px;}\r\n\r\ntest:function(){\r\n\tconsole.log('test');\r\n}会发现样式不起作用。另外就是绑定事件也无法起作用,如上面的test,点击后无效，跟刚才说的li标签被过滤同样的道理。tabBar配置决定了首页在app.JSON中，我改了一下pages首页的位置，发现并不起作用，反而tabBar改了第一个标签的地址后，首页也跟着改变，而微信是支持tabBar可以不是首页进来的页面。wxs 改为 filter微信的：WXS（WeiXin Script）是小程序的一套脚本语言，结合 WXML，可以构建出页面的结构。<!--wxml-->\r\n<wxs module=\"m1\">\r\nvar msg = \"hello world\";\r\n\r\nmodule.exports.message = msg;\r\n</wxs>\r\n\r\n<view> {{m1.message}} </view>\r\n\r\n页面输出：\r\n\r\nhello world\r\n百度的：Filter 是小程序的过滤器，结合 SWAN 模版，可以构建出页面的结构。// page.js\r\nPage({\r\n  data: {\r\n    array: [1, 3, 6, 8, 2, 0]\r\n  }\r\n});\r\n\r\n// test.filter.js\r\nexport default {\r\n    maxin: (arr) => {\r\n        var max = undefined;\r\n        for (var i = 0; i < arr.length; ++i) {\r\n            max = max === undefined ?\r\n            arr[i] :\r\n            (max >= arr[i] ? max : arr[i]);\r\n        }\r\n        return max;\r\n    }\r\n};\r\n\r\n<!-- swan模版 -->\r\n<view>{{swan.maxin(array)}}</view>\r\n<filter src=\"./test.filter.js\" module=\"swan\"></filter>\r\n\r\n页面输出：\r\n\r\n8\r\n自定义组件模板里面没法嵌套模板建议使用slot图片路径要补全协议如下面这两种情况，如果没有补全协议，会无法访问，默认代码为静态解析<image src=\"//www1.pchouse.com.cn/2018/weixinminipro/loading.png\"></image>\r\n\r\n//css \r\nimage{background:url(//www1.pchouse.com.cn/2018/weixinminipro/loading.png)}\r\nimport 和 includeimport 注意微信中引入的是.wxml的文件，百度这里引入的是.swan的文件，所以要替换掉在 index.swan 中引用了 item.swan，就可以使用item模板：<import src=\"item.swan\"/>\r\n<template is=\"item\" data=\"{{{preson}}}\"/>\r\n同理 include也是改文件后缀<!-- index.swan -->\r\n<include src=\"header.swan\"/>\r\n<view> body </view>\r\n<include src=\"footer.swan\"/>\r\n百度小程序分享到微信，无法打开百度虽然提供了分享到微信朋友圈和微信好友的功能，但打开微信分享的内容会先提示跳到App Store上，并无法打开百度小程序的页面，分享体验不好，只能分享到百度APP自身的动态，打开后才能访问。微信转换为百度小程序1.登录百度小程序开发工具，在工具菜单，有一个一键转换微信的小程序为百度小程序。（前提：有审核通过的appid，并且登录开发者工具）用了官方的工具还是挺好的，对照我上面提到的点，小小的调整应该就差不多了。2.下载NPM上的一个工具：wx2swan。https://github.com/yican008/wx2swan，跟百度这个转换好像差不多。安装： npm i -g wx2swan转换：wx2swan 微信小程序的目录 (生成swan的目录)wx2swan ./test/demo ./test/swanDemo3.使用 Taro 开发2018.11.20日更新：bindscrolltolower 执行多次scroll-view 组件的bindscrolltolower 会执行多次，需要加上防抖处理，预防接口重复加载，导致数据更新混乱，出现错误。<scroll-view bindscrolltolower=\"loadMoreList\"></scroll-view>\r\n\r\nPage({\r\n\ttimer:null,\r\n\tloadMoreList:function(){\r\n\t\tvar self = this;\r\n\t\tif(this.timer){\r\n\t\t\tclearTimeout(this.timer);\r\n\t\t}\r\n\t\tthis.timer = setTimeout(function(){\r\n\t\t\tconsole.log('your data');\r\n\t\t\tself.timer = null;\r\n\t\t},300);\r\n\t}\r\n})\r\n双向绑定1.scroll-view组件里面有三个属性是属性双向绑定<scroll-view scrollTop=\"{= scrollTop =}\" scrollLeft=\"{= scrollLeft =}\" scroll-into-view=\"{= scrollIntoView =}\"></scroll-view>2.input组件<input value=\"{= value =}\"/>真机的屏幕高度没有去掉tabBar高度2019.1.17号更新：在DOM加载完毕是正确的，屏幕高度会去掉tabBar,所以应该在onReady生命周期里面处理。由于scroll-view组件需要确定高度，在电脑上计算出来的高度是已经对的，但到了真机上，发现高度并没有减掉tabBar的高度，导致有些地方被隐藏在tabBar下面。没办法，我只能用了另外一种办法，因为我怕到时候它修复了这个错误，我一hack它这个高度，那时候我又得改了。我给scroll-view的父类加了一个绝对定位属性。然后定义它的高度为100%，接着在scroll-view的组件里面减去头部的导航高度。<view class=\"fix-menu\"></view>\r\n<view class=\"tab-content\">\r\n<scroll-view class=\"content\">\r\n<view class=\"list\">\r\n</view>\r\n</scroll-view>\r\n</view>\r\n\r\n.fix-menu{height:100rpx; position:fixed; top:0; left:0; width:100%;}\r\n.tab-content{position:absolute; left:0; top:0; height:100%; width:100%;}\r\n.content{height:100%;}\r\n.content .list{padding-top:100rpx;}\r\n这样子就不需要去计算scroll-view的高度了。直接用css兼容，也不用管百度这个bug了。不过微信的还是直接计算这个高度比较好，这样子这个scroll-view刚开始时的滚动条就不会被隐藏掉100rpx。百度小程序分享安卓中分享到百度动态，点击消息进入时，无法进入具体页面，只能进入当前页或者首页。2019.1.24更新API微信小程序有的API，而百度小程序没有的一个表，不对下面这些微信小程序API进行转换wx: {\r\n        startRecord,\r\n        stopRecord,\r\n        playVoice,\r\n        pauseVoice,\r\n        stopVoice,\r\n        getBackgroundAudioPlayerState,\r\n        playBackgroundAudio,\r\n        pauseBackgroundAudio,\r\n        seekBackgroundAudio,\r\n        stopBackgroundAudio,\r\n        onBackgroundAudioPlay,\r\n        onBackgroundAudioPause,\r\n        onBackgroundAudioStop,\r\n        openBluetoothAdapter,\r\n        closeBluetoothAdapter,\r\n        getBluetoothAdapterState,\r\n        onBluetoothAdapterStateChange,\r\n        startBluetoothDevicesDiscovery,\r\n        stopBluetoothDevicesDiscovery,\r\n        getBluetoothDevices,\r\n        getConnectedBluetoothDevices,\r\n        onBluetoothDeviceFound,\r\n        createBLEConnection,\r\n        closeBLEConnection,\r\n        getBLEDeviceServices,\r\n        getBLEDeviceCharacteristics,\r\n        readBLECharacteristicValue,\r\n        writeBLECharacteristicValue,\r\n        notifyBLECharacteristicValueChange,\r\n        onBLEConnectionStateChange,\r\n        startBeaconDiscovery,\r\n        stopBeaconDiscovery,\r\n        getBeacons,\r\n        onBeaconUpdate,\r\n        onBeaconServiceChange,\r\n        getHCEState,\r\n        startHCE,\r\n        stopHCE,\r\n        onHCEMessage,\r\n        sendHCEMessage,\r\n        startWifi,\r\n        stopWifi,\r\n        connectWifi,\r\n        getWifiList,\r\n        onGetWifiList,\r\n        setWifiList,\r\n        onWifiConnected,\r\n        getConnectedWifi,\r\n        setTopBarText,\r\n        showShareMenu,\r\n        hideShareMenu,\r\n        updateShareMenu,\r\n        getShareInfo,\r\n        addCard,\r\n        openCard,\r\n        getWeRunData,\r\n        checkIsSupportSoterAuthentication,\r\n        startSoterAuthentication,\r\n        checkIsSoterEnrolledInDevice,\r\n        faceVerifyForPay,\r\n\r\n    }微信小程序被废弃的接口，建议用后面的接口替换createContext：被废弃的函数，建议使用createCanvasContext替代\r\ndrawCanvas：被废弃的函数，建议使用createCanvasContext替代\r\ncreateAudioContext：建议用createInnerAudioContext两者有些不同的，前面是微信，百度的用后面的替换navigateToMiniProgram--->navigateToSmartProgram微信二级API，目前百度不支持的createLivePusherContext自定义组件// Component构造器中不支持的属性\r\n    Component: {\r\n        moved: null,\r\n        relations: null\r\n    },\r\n    Behavior: {\r\n        // Behavior 中不支持自定义组件的扩展\r\n        // definitionFilter: null\r\n    },\r\n    // 自定义组件中this上不支持的属性和方法\r\n    this: {\r\n        getRelationNodes: null,\r\n        selectComponent: {\r\n            // 方法不允许被调用的作用域\r\n            notAllowParents: ['onLaunch', 'onShow', 'onLoad']\r\n        },\r\n        selectAllComponents: {\r\n            // 方法不允许被调用的作用域\r\n            notAllowParents: ['onLaunch', 'onShow', 'onLoad']\r\n        }\r\n    },\r\n    // 设置内置behaviors映射关系\r\n    behaviors: {\r\n        'wx://form-field': {\r\n            mapping: 'swan://form-field'\r\n        },\r\n        'wx://component-export': {\r\n            mapping: 'swan://component-export'\r\n        }\r\n    },\r\n    json: {\r\n        // 不支持抽象节点\r\n        componentGenerics: null\r\n    }左边是微信，右边是百度template组件data属性转换问题: {{item}} => {{{item}}}<template is=\"person-card\" data=\"{{person}}\" />\r\nwx:for不同，百度可以浓缩到一个属性里面。s-for=\"item,p in obj\"---> wx:for=\"{{obj}}\" wx:for-item=\"item\" wx:for-index=\"p\"\r\n转换wx.__route__成员表达式调用为wx.route参考链接搬家工具转换支持的Feature List百度小程序开发问题汇总"}
{"title": "小程序组件开发之时间轴组件及组件关系 ", "author": "Rolan", "time": "2019-10-15 00:16", "abstract": "本文是面向初学者的，大牛可以忽略，以时间轴组件为例简单聊一下小程序的组件开发。先简单介绍一下公司业务和前端项目情况吧。公司是做金融行业财富管理的业务，涉及主要是做基金、保险这一块。前端项目目前涉及B端 ...", "content": "本文是面向初学者的，大牛可以忽略，以时间轴组件为例简单聊一下小程序的组件开发。先简单介绍一下公司业务和前端项目情况吧。公司是做金融行业财富管理的业务，涉及主要是做基金、保险这一块。前端项目目前涉及B端后台管理系统、C端小程序、Node服务端，其中业务重点在小程序端，我们只有微信小程序端，没有做其他小程序，也没有使用市面上流行的各种多端框架，我们使用原生开发方式，UI组件我们也选择了自研，目前我们开发了一套金融风格的小程序端UI组件库，有过开源的打算，但目前我们还在内部沉淀使用中，目前积累了 34+ 个组件了，支持主题和国际化，基本上满足了目前开发的需要。所以，本文要说的是我们组件库最近添加的一个新组件，时间轴组件，也是笔者开发的，笔者由于在公司主要负责小程序端的开发，基于业务的需要贡献了开发了不少组件，那么多组件之所以讲这个组件，是因为其他大部分组件的开发都很普通，体现不了小程序特有的东西，要么是组件太复杂代码太多不适合用文字表达，而时间轴（Timeline）组件我觉得刚刚好，不肥不瘦不偏不倚20不足18有余，比较好拿来作为素材聊聊。另外，为了写本文我把此组件做成了 小程序代码片段 ，代码片段是一种可分享的小项目，可用于分享小程序和小游戏的开发经验、展示组件和 API 的使用、复现开发问题等等，代码片段详细信息可以去官方文档看看。时间轴组件（源代码）代码片段 ，点击链接可以直接通过小程序开发工具直接打开查看，可以边看源代码边看文章。注意：请确保你的开发者工具版本 >= 1.02.1904280组件分析设计在着手写代码之前，还是先做一翻分析设计。分析什么？我们需要分析业务方对组件的详细需求、交互以及设计稿效果，弄清楚有没有什么特别的地方，需求是否适合使用时间轴组件来呈现等，对于不合理的需求，作为开发我们有责任提出问题和建议来。设计什么？我们需要设计组件的目录结构、API以及对使用者友好的示例文档，通常除了API外，目录结构、命名和文档我们都会现有一个规范，按给定的规范做即可，但是如何设计一组好的API就需要开发者具有一定的经验。当然，对于常用的组件，我们也许用不着这么认真，直接参考市面上已有的组件库找着样子抄就行了，事实上我们除了少数几个组件别具特色外别家没有外，其他组件我们也是直接参考别的组件库是怎么做的，但我这里抛砖引玉吧，不仅仅是开发组件，任何需求的迭代开发都是一样的，特别是复杂的需求，我们更需要设计。对于组件开发来说，最好的设计文档就是示例文档，文档先行。看一下 Timeline 组件的文档吧：Timeline 组件的文档什么不支持自定义 slot，什么地方支持自定义，这就很清晰了，事件轴点可以自定义样式，时间轴的内容体可以自定义，以及一些外部样式 class。当然这是最终完善的文档，我们首先应该定义好组件的 Attributes（Props）、Slot ，命名、类型这些都事先定义好，这是最基础的，分析出来我们的组件应该提供什么样的能力，定义什么样的接口。其次，我们应该写好代码示例，先想好我们的组件是如何使用的，然后我们再支持这样的实现。这里可以看出，组件使用了父子嵌套组件模式：<pps-timelinereverse=\"{{false}}\">\r\n  <pps-timeline-item\r\n    wx:for=\"{{activity}}\" \r\n    wx:key=\"{{index}}\"\r\n    timestamp=\"{{item.timestamp}}\"\r\n    dotStyle=\"border-color: #33cd5f; color: #33cd5f\">\r\n      {{item.content}}\r\n  </pps-timeline-item>\r\n</pps-timeline>\r\n为什么这里要使用父子组件模式呢，其实不这样也是可以很好的完整组件。做好了这些工作后我们开始写代码吧。组件实现timeline因为我们是使用父子组件嵌套模式，所以在创建目录时就可以这样体现：timeline\r\n--index.wxml\r\n----timeline-item\r\n------index.wxml\r\n当然，在小程序中要实现父子组件关联关系并不是非要这样，事实上没有层级规定限制，父子组件平级放置也是可以的，但我推荐这样，阅读起来更清晰名了。父组件内部其实很简单，就是一个 slot，以便能够放入子组件<!-- timeline/index.wxml -->\r\n<viewclass=\"pps-timeline custom-class {{reverse?'desc':'asc'}}\">\r\n  <slot/>\r\n</view>\r\ncustom-class 是定义组件的根外部样式，以便在外部传入样式，为什么要这样呢，小程序的组件技术采用的 WebCompontent 技术，不了解的同学可以搜索一下，这里我写了 demo 。 reverse 是个 prop ，控制时间轴是顺序展示还是倒序展示，这个在父组件来控制是最好不过的（当然，你也可以把传入的数组排序好也是一样的）。timeline-item核心都在这个里面，我们先来分析一下DOM结构，以便确定怎么构建HTML结构具体代码就不贴了，可以打开代码片段查看。排序：父子组件间关系组件间关系这是这个组件最关键的地方，不同于 Vue.js 组件方案，只有实现这个才能实现在 timeline 上实现 reverse。关于组件的关联关系详细可以看 文档 。在 timeline/index.js 和 timeline-item/index.js 中分别定义 timeline 是 timeline-item 的父级，timeline-item 是 timeline 的子级，由 relations 选项来定义。关键是确定最后一个节点，因为最后一个节点是没有连接线的，这个需要处理（其实数据不复杂的情况下更建议对传入的数组进行排序，这样就不需要处理DOM结构了）。timeline/index.jsrelations: {\r\n    './timeline-item/index': {\r\n      type: 'child',\r\n      linked: function (target){\r\n        // 每次有custom-li被插入时执行，target是该节点实例对象，触发在该节点attached生命周期之后\r\n        this._getAllChildren()\r\n      },\r\n      unlinked: function (target){\r\n        this._getAllChildren()\r\n      }\r\n    }\r\n  },\r\ntimeline-item/index.jsrelations: {\r\n    '../../timeline/index': {\r\n      type: 'parent'\r\n    }\r\n  },\r\n有了关联关系，我们可以调用 this.getRelationNodes 方法获取所有的子节点，这个写在 timeline-item/index.js 中methods: {\r\n    _getAllChildren() {\r\n      const nodes = this.getRelationNodes('./timeline-item/index')\r\n      if (nodes.length) {\r\n        const lastIndex = nodes.length - 1\r\n        const { reverse } = this.data\r\n        nodes.forEach((element, index) => {\r\n          const isLast = index === lastIndex\r\n          element.updateIsLastElement({\r\n            index,\r\n            isLast,\r\n            reverse\r\n          })\r\n        })\r\n      }\r\n    }\r\n}\r\n然后遍历每一个子节点，调用子节点 methods 中的 updateIsLastElement 处理方法。这里需要特别注意的是 在 unlinked 中也要再次调用 _getAllChildren ，因为当使用 setData 删除一个子项时需要重新计算子节点个数。所谓的排序，就是 Flex CSS 操作而已.pps-timeline.desc{\r\n  display: flex;\r\n  flex-direction: column;\r\n}\r\n.pps-timeline.asc{\r\n  display: flex;\r\n  flex-direction: column-reverse;\r\n}\r\n这个组件还有很多可以改进的地方，这里作为一种思路吧。注意在引用小程序端的时候，父子组件都需要在json中引入，如果你的项目是用 npm 进行管理的，那么不要在全局的 app.json 中引入，要在使用的页面中引入，否则引用不到。推荐几个优秀的组件库iView Weapp 。出自著名的Vue组件库 iView 之家，跟 iView 一脉相承。Vant Weapp 。“大名鼎鼎”的大厂有赞出品，Vue 组件库 Vant 的小程序版本，两者基于相同的视觉规范，提供一致的 API 接口。Color UI 。最“风骚”的组件库，多彩靓丽，组件丰富，色彩华丽，动画酷炫。wux-weapp 。最大而全的组件库，各种组件应有尽有，组件宝库。后记笔者小程序开发经验也不是很丰富，如有错误请指出，小程序的自定义组件涉及的东西比 Vue.js 多多了，比如模板和样式怎么处理、组件间通信、组件间关系、组件生命周期等都具有小程序特色。纯原生开发一个复杂的小程序，不借助轮子个人感觉还是很麻烦的，尤其现在这么多小程序，哪天需要支持其他小程序呢，我想不会有人一个个对接原生开发吧，由于我们业务时toB的，所以目前还不需要考虑其他平台小程序。"}
{"title": "微信小程序之Flex容器详解 ", "author": "Rolan", "time": "2019-10-15 00:21", "abstract": "Flex 是 W3C 提出的一种新的布局方案，可以非常方便的完成响应式页面布局，到目前为止几乎所有浏览器都支持，Flex 是 Flexible Box 的缩写，翻译过来是\"弹性布局\"的意思，下面一起来学习 Flex 布局的使用。  基础概  ...", "content": "Flex 是 W3C 提出的一种新的布局方案，可以非常方便的完成响应式页面布局，到目前为止几乎所有浏览器都支持，Flex 是 Flexible Box 的缩写，翻译过来是\"弹性布局\"的意思，下面一起来学习 Flex 布局的使用。\r\n\r\n基础概念\r\nflex容器属性\r\nflex项目属性\r\n总结\r\n\r\n基础概念\r\n采用 Flex 布局的元素称为 Flex 容器，所有子元素将自动成为容器成员，也可以称之为 Flex 项目，也就是该 Flex 布局的子 View ,下面是 Flex 布局默认设置下的示意图：\r\n\r\n如上图所示，默认的 Flex 容器的存在两个轴：水平的主轴(main axis)和垂直的交叉轴(cross axis)，主轴和交叉轴的方向不是绝对的，而是会因为设置的不同而不同，下面是与主轴和交叉轴相关的几个位置：\r\n\r\n主轴起始点(main start):主轴的开始位置\r\n主轴的结束点(main end):主轴的结束位置\r\n主轴空间(main size):单个 Flex 项目占据的主轴空间\r\n交叉轴的起始点(cross start):交叉轴的起始点\r\n交叉轴的结束点(cross end):交叉轴的结束点\r\n交叉轴空间(cross size):单个 Flex 项目占据的交叉轴空间\r\n\r\nflex容器属性\r\n\r\nflex-direction：设置主轴的方向，可设置的值如下：\r\n\r\n\r\nrow：默认值，设置主轴为水平方方向，起点在左边\r\nrow-revarse：设置主轴为水平方向，起点在右边\r\ncolumn：设置主轴为垂直方向，起点在上边\r\ncolumn-revarse：设置主轴为垂直方向，起点在下边\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nflex-wrap：设置如何换行，可设置的值如下：\r\n\r\n\r\nnowrap：默认值，不换行\r\nwap：自动换行\r\nwrap-revarse：自动换行，在第一行的上一行\r\n\r\n\r\n\r\n\r\nnowrap\r\nwap\r\nwrap-revarse\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nflex-flow：flex-direction 属性和 flex-wrap 属性的简写形式，默认值为 row nowrap。\r\n\r\n\r\njustify-content：设置项目在主轴上的对齐方式，可设置的值如下：\r\n\r\n\r\n\r\nflex-start：默认值，左对齐\r\nflex-end：右对齐\r\ncenter：居中对齐\r\nspace-between：两端对齐\r\nspace-around：每个项目两侧的间隔相等，与屏幕边缘的间隔是其他项目之间间隔的一半\r\nspace-evenly：平均分布各个项目，与屏幕边缘的间隔与其他项目之间的间隔相等\r\n\r\n\r\n\r\n\r\nflex-start\r\nflex-end\r\ncenter\r\nspace-between\r\nspace-around\r\nspace-evenly\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nalign-items：设置项目在交叉轴上如何对齐，可设置的值如下：:默认值，如果没有项目未指定高度或设置为auto,则项目会占满整个容器的高度，可设置的值如下：\r\n\r\n\r\nstretch：默认值，如果没有项目未指定高度或设置为auto,则项目会占满整个容器的高度，下面图示中项目 1 就未指定高度，其余项目都指定了高度\r\n就未指定高度\r\nflex-start：设置与交叉轴的起点对齐\r\nflex-end：设置与交叉轴的结束点对齐\r\ncenter：设置与交叉轴的重点对齐\r\nbaseline：设置项目与项目中第一行文字基线对齐\r\n\r\n\r\n\r\n\r\nstretch\r\nflex-start\r\nflex-end\r\ncenter\r\nbaseline\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nalign-content：设置多根轴线的对齐方式，如果只有一个轴则该属性不生效，可设置的属性如下：\r\n\r\n\r\nstretch：默认值，轴线占满整个交叉轴\r\nflex-start：设置与与交叉轴的起点对齐\r\nflex-end：设置与交叉轴的终点对齐\r\ncenter：设置与交叉轴的中点对齐\r\nspace-between：设置与交叉轴两端对齐，轴线之间的间隔平均分布\r\nspace-around：设置每根轴线两侧的间隔都相等，轴线与轴线的间隔是轴线到交叉轴边缘间隔的两倍\r\n\r\n\r\n\r\n\r\nstretch\r\n\r\n\r\n\r\n\r\nflex项目属性\r\n\r\n\r\norder：默认值为0，设置项目的排列顺序，数值越小，排列越靠前，如下图所示：\r\n\r\n\r\n\r\nflex-grow：设置项目的放大比例，默认值为0，如果存在剩余空间也不放大，如下图所示：\r\n\r\n\r\n\r\n\r\nflow-grow=0\r\nflow-grow=1\r\nflow-grow设置不同值\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nflex-shrink：设置项目的缩小比例，默认值为 1，如果项目空间不足，则项目将缩小，如下图所示：\r\n\r\n\r\n\r\n\r\nflow-shrink=1\r\nflow-shrink=0\r\nflow-shrink设置不同值\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n上面图示中，当 flex-shrink 全设置为 0，每个项目不会缩放，所以第四个方块被挤出去了，而相应的设置 flex-shrink 为 1，则可以在空间不足是进行一定程度的缩放。\r\n\r\nflex-basis：项目所占的主轴空间，如下图所示：\r\n\r\n\r\n\r\nalign-self：定义元素自身的对齐方式，该属性与 align-items 属性差不多，具体就不一一介绍了，直接上效果图如下：\r\n\r\n\r\n\r\n\r\nauto\r\nstretch\r\nflex-start\r\nflex-end\r\ncenter\r\nbaseline\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n上面的效果中设置 auto 会跟随 flex 容器中 align-items 的设置。\r\n\r\nflex：flex 是 flex-grow, flex-shrink 和 flex-basis 的简写，默认值为0 1 auto，这里就不在贴效果图了。\r\n\r\n总结\r\n最近尝试了一下微信小程序，感觉开发起来难度也不是很大，觉得本篇文章的内容也是微信小程序中最重要的内容了，本来打算继续进行小程序系列的学习，但是看了一下后面的内容无非就是小程序各个组件的使用了，如果有其他项目的开发经验，实在没必要一个组件一个组件去验证学习，所以小程序的学习就到此为止，最后，说一点微信小程序最重要的我觉得还是 Flex 布局。可以选择关注个人微信公众号：jzman-blog 获取最新更新，一起交流学习!"}
{"title": "教你制作挂件头像 | 小程序七十二变之 canvas 绘制国旗头像 ", "author": "Rolan", "time": "2019-10-15 00:32", "abstract": "朋友圈被「请给我一面国旗@微信官方」刷屏，虽然知道是假的，但是从另一个角度来看，弄清楚如何实现更有趣。1、canvas这就不得不提到小程序中的 APIcanvas，H5 中也是有 canvas 的，不过之前也一直没有机会用，这次 ...", "content": "朋友圈被「请给我一面国旗@微信官方」刷屏，虽然知道是假的，但是从另一个角度来看，弄清楚如何实现更有趣。1、canvas这就不得不提到小程序中的 API canvas，H5 中也是有 canvas 的，不过之前也一直没有机会用，这次正好乘机试试水。晚上回家看了下官方文档，网上搜了一些类似的功能实现，最后写好了一个 demo，基本上是能初步绘制国旗头像了。当然以后如果想要绘制其他带挂件的头像，只需要更改挂件素材即可，提前预约帮你们定做今年的圣诞帽。 2、代码来了实现过程主要分为以下几个步骤：1、新建 canvas 画板2、绘制头像当做背景（demo 目前是自行上传头像制作）3、绘制国旗边框4、保存到手机相册（需授权）废话不多说，直接上代码：// wxml 页面\r\n<view class=\"container\">\r\n  <!-- 头像绘制区域 -->\r\n  <canvas canvas-id=\"myAvatar\" class=\"canvas\"></canvas>\r\n\r\n  <!-- 按钮 -->\r\n  <button class=\"btn-save\" bindtap=\"upload\">上传头像</button>\r\n  <button disabled=\"{{ !save }}\" class=\"btn-save\" bindtap=\"saveImg\">保存到相册</button>\r\n</view>// 部分功能 js\r\n// 绘制头像背景\r\ndrawAvatar() {\r\n  var that = this;\r\n  var p = that.data;\r\n  context = wx.createCanvasContext('myAvatar', this);\r\n  context.drawImage(p.src, 0, 0, 256, 256);\r\n  context.draw(true)\r\n  context.save();\r\n  context.translate(p.hat.x, p.hat.y)\r\n  context.scale(p.hat.b, p.hat.b)\r\n  context.rotate(p.hat.rotate * Math.PI / 180)\r\n  context.drawImage(p.hat.url, 0, 0, p.hat.w, p.hat.h)\r\n  context.draw(true)\r\n  this.setData({\r\n    save: true\r\n  })\r\n},\r\n\r\n// 保存图片\r\nsaveImg() {\r\n  wx.canvasToTempFilePath({\r\n    canvasId: 'myAvatar',\r\n    success(res) {\r\n      wx.saveImageToPhotosAlbum({\r\n        filePath: res.tempFilePath,\r\n        success(res) {\r\n          wx.showToast({\r\n            title: '保存成功'\r\n          })\r\n        },\r\n        fail(res) {\r\n          wx.showToast({\r\n            title: '取消保存...',\r\n            icon: 'none'\r\n          })\r\n        }\r\n      })\r\n    }\r\n  })\r\n} 3、最后demo 写完了，以小程序的尿性，怎么会没有坑呢？发现真相的我眼泪差点掉下来，而且这个坑不是一般的坑，弄了老半天都没解决。具体是啥坑小程序留言区揭晓，感兴趣的欢迎来留言讨论如何解决，到发文为止依旧是个巨坑。公众号「我是玖柒后」后台回复「头像」即可获取 demo 源码，填坑不忘挖坑人，我太南了。"}
{"title": "小程序九九八十一坑之头像模糊，谁的锅？ ", "author": "Rolan", "time": "2019-10-15 00:46", "abstract": "「柒留言」更新的换国旗头像小功能，获取头像显示模糊...1、头像模糊国庆之前，更新了「柒留言」小程序加国旗头像的小功能，但是头像模糊这个坑我在发布新版之前还没解决。一直以为是代码出了问题，各种搜索，巧的是 ...", "content": "「柒留言」更新的换国旗头像小功能，获取头像显示模糊...1、头像模糊国庆之前，更新了「柒留言」小程序加国旗头像的小功能，但是头像模糊这个坑我在发布新版之前还没解决。一直以为是代码出了问题，各种搜索，巧的是正好也有类似的答案，然后我就被带进锅里了，弄了半天还是模糊，无奈之下弄了个用户自行上传图片生成头像，这样生成的头像就能清晰显示，先发布新版。发布新版后仔细研究了一下头像，发现显示在浏览器上是小图，一度以为是自己上传了略缩图，于是乎重新上传高清图像，然并 L。最后在头像地址上找到了问题。2、默认模糊？这是我的头像地址，滑动到最右，你发现了啥？1http://wx.qlogo.cn/mmopen/eTBFF2uBxbBTAW8ZrbmMJGuOq7nGZfGicWORE2vcZfsMwXscofgeEwevlSl8L5SFFct2ZKibzxjqNjw94r2wI2xiaibY3TKxVRPC/132/ 后面带了个 132，猜想一下这个是头像尺寸，于是乎搜一下微信文档，果然。是在下输了，怪我没有仔细看文档，谁知道一个头像获取还要分尺寸的，这里把 132 改成 0 就是高清头像了，改的逻辑就不用多说了吧，我相信你们会的。其实，132 的头像用在小程序中已经很清楚了，只不过我绘制头像时用的尺寸是 256px，差不多是把头像放大了一倍，所以显示是模糊的。这个锅，我先背为敬。3、肝项目最近公司在肝项目上线，尽量压缩中午的午休时间更新一下遇到的坑。大概率不是那么的硬核，但希望能帮大家少踩坑。干货都是相对的，觉得对你有帮助点个在看吧，大佬路过就行。Demo 已更新，线上版本未更新，加了点好玩的：教程 | 小程序七十二变之 canvas 绘制国旗头像GitHub 获取制作国旗头像源码"}
{"title": "小程序云开发攻略,解决最棘手的问题 ", "author": "Rolan", "time": "2019-9-30 00:02", "abstract": "背景最近小程序非常的火,应公司业务发展要求,开发维护了几款小程序,公司开发的小程序都是由后端提供的接口,开发繁琐而复杂,直到小程序出现了云开发,仔细研读了文档之后,欣喜不已,于是我着手开发了本人的第一款小程序 ...", "content": "背景最近小程序非常的火,应公司业务发展要求,开发维护了几款小程序,公司开发的小程序都是由后端提供的接口,开发繁琐而复杂,直到小程序出现了云开发,仔细研读了文档之后,欣喜不已,于是我着手开发了本人的第一款小程序小程序云开发教程地址 点我查看>>分析云开发为开发者提供完整的原生云端支持和微信服务支持，弱化后端和运维概念，无需搭建服务器，使用平台提供的 API 进行核心业务开发，即可实现快速上线和迭代，同时这一能力，同开发者已经使用的云服务相互兼容，并不互斥。优势无需自建服务器,数据库,无需自建存储和CDN数据库模型很简单,就是一个json形式的对象格式调用服务端云函数自动获取openid,再也没有繁琐的授权登陆流程了,只要进入小程序就是登陆状态,体验真的好开发迅速,只需要前端就能搞定所有开发工作需要解决的问题数据库切换问题使用过云开发的人都发现云开发切换数据库环境是最头疼的,如果手动去切换容易搞错,不小心在当前环境修改了线上数据库数据直到官方出了这个函数问题也就迎刃而解cloud.updateConfig({\r\n    env: ENV === 'local' ? 'dev-aqijb' : ENV\r\n  });我使用的是服务端云开发功能,为什么要这样判断,因为在开发工具中ENV = 'local',所以这么判断一下,保证开发工具中使用的是测试环境数据库使用taro多端开发框架,借助于webpack,还可以通过process.env.NODE_ENV值区分当前代码开发环境await Taro.cloud.init({\r\n        env: `${process.env.NODE_ENV === 'development' ? 'dev-aqijb' : 'pro-hljv7'}`\r\n        /* env: 'pro-hljv7' */\r\n      });这样可以保证开发环境和线上环境可以使用对应环境的数据库数据库字段定义问题因为JS是弱类型语言,不能像typescript那样静态定义变量类型,这样添加到数据库的字段数量和字段类型都无法控制我不想用typescript,能不能实现这样的功能呢,可以用superstruct库来实现这个功能superstruct git地址 点我查看>>详细使用案例见下方代码函数文件太多的问题官方和他人教程的例子都是一个文件对应一个云函数,通过开发体验我发现这样做并不好,当项目有多个表的时候,找个函数文件真的太难了我们可以将一个表的增删改查函数全部写入一个文件中教程: 首先每个云函数文件中package.json引入superstruct{\r\n  \"dependencies\": {\r\n    \"wx-server-sdk\": \"latest\",\r\n    \"superstruct\": \"latest\"\r\n  }\r\n}以下代码是一个完整的云函数例子const cloud = require('wx-server-sdk');\r\nconst { struct, superstruct } = require('superstruct');\r\ncloud.init();\r\n//小区信息\r\nconst Model = () => {\r\n  const db = cloud.database();\r\n  const _ = db.command;\r\n  const collection = db.collection('address');\r\n  return {\r\n    async add(data) {\r\n      try {\r\n        data = struct({\r\n          name: 'string', //名字\r\n          phone: 'string',\r\n          unit: 'number', //楼单元号\r\n          doorNumber: 'string', //门号\r\n          communityId: 'string', //小区id\r\n          _openid: 'string' //用户的id\r\n          //isDefault: 'boolean' //是否默认地址\r\n        })(data);\r\n      } catch (e) {\r\n        const { path, value, type } = e;\r\n        const key = path[0];\r\n\r\n        if (value === undefined) {\r\n          const error = new Error(`${key}_required`);\r\n          error.attribute = key;\r\n          throw error;\r\n        }\r\n\r\n        if (type === undefined) {\r\n          const error = new Error(`attribute_${key}_unknown`);\r\n          error.attribute = key;\r\n          throw error;\r\n        }\r\n        const error = new Error(`${key}_invalid`);\r\n        error.attribute = key;\r\n        error.value = value;\r\n        throw error;\r\n      }\r\n      let res = await this.getList({ _openid: data._openid });\r\n      if (res.data.length >= 1) {\r\n        return { msg: '当前只支持保存一个地址' };\r\n      }\r\n      res = await collection.add({\r\n        data,\r\n        createTime: db.serverDate(),\r\n        updateTime: db.serverDate()\r\n      });\r\n      return res;\r\n    },\r\n    async getAdressById({ _openid, _id }) {\r\n      const user = await collection\r\n        .where({\r\n          _openid,\r\n          _id: _.eq(_id)\r\n        })\r\n        .get();\r\n      return user;\r\n    },\r\n    //更新指定的id 先判断手机号修改没,没修改直接就改数据,修改过判断一下库中有没有这条数据\r\n    async update(data) {\r\n      //更新表的操作\r\n    },\r\n    //删除指定id的shop\r\n    async remove({ _id, _openid }) {\r\n      //删除表的操作\r\n    },\r\n    /**\r\n     * 获取商列表\r\n     * @param {*} option {category 类别, pagenum 页码}\r\n     */\r\n    async getList({ _openid }) {\r\n      const shopList = await collection\r\n        .where({\r\n          _openid\r\n        })\r\n        .get();\r\n\r\n      return shopList;\r\n    }\r\n  };\r\n};\r\n\r\nexports.main = async (event, context) => {\r\n  const { func, data } = event;\r\n  const { ENV, OPENID } = cloud.getWXContext();\r\n  // 更新默认配置，将默认访问环境设为当前云函数所在环境\r\n  console.log('ENV', ENV);\r\n  cloud.updateConfig({\r\n    env: ENV === 'local' ? 'dev-aqijb' : ENV\r\n  });\r\n  let res = await Model()[func]({ ...data, _openid: OPENID });\r\n  return {\r\n    ENV,\r\n    data: res\r\n  };\r\n};函数使用方式wx.cloud.callFunction({\r\n      'address', //云函数文件名\r\n      data: {\r\n        func: 'add', //云函数中定义的方法\r\n        data: {} //需要上传的数据\r\n      }\r\n    });图片 视频等文件直接打开云开发控制台选择存储直接上传文件,复制url地址就可以放到代码中使用了扫码体验我的小程序:"}
{"title": "用小程序·云开发轻松构建二手书商城小程序 ", "author": "Rolan", "time": "2019-9-30 00:09", "abstract": "“拱手让书，智慧相传。本文将带大家使用云开发快速开发完整的校园二手书商城“导语很多大学有个普遍现象，毕业或者搬校区的时候，成堆成堆的书都被随便处理掉，作为过来人，每每想到都十分痛心可惜，而导致这种情况 ...", "content": "“拱手让书，智慧相传。本文将带大家使用云开发快速开发完整的校园二手书商城“导语很多大学有个普遍现象，毕业或者搬校区的时候，成堆成堆的书都被随便处理掉，作为过来人，每每想到都十分痛心可惜，而导致这种情况发生的原因，我认为主要还是归结学校原因，一方面没有提供靠谱便利的平台，另一方面，宣传不到位，基于此开发了这款小程序。下面挑了些开发过程中遇到的典型来讲解实现过程，感兴趣可以一览......一：登录注册页目前小程序有了详细的登录规范，参考官方示例，本程序的登录入口做了以下处理：在需要涉及用户信息的部分，进行Modal提示进入，比如：游客发布、购买等个人中心，未登录默认显示”点击登录“按钮好了，先来看看登录页面效果图吧：手机号获取（相关代码）：<button class=\"phone\" open-type=\"getPhoneNumber\" bindgetphonenumber=\"getPhoneNumber\">\r\n                  <block wx:if=\"{{phone==''}}\"> 请点击获取您的手机号</block>\r\n                  <block wx:if=\"{{phone!==''}}\"> {{phone}}</block>\r\n                  <image wx:if=\"{{phone==''}}\" class=\"right\" src=\"/images/right.png\" />\r\n</button>//获取用户手机号\r\n      getPhoneNumber: function(e) {\r\n            let that = this;\r\n            //判断用户是否授权确认\r\n            if (!e.detail.errMsg || e.detail.errMsg != \"getPhoneNumber:ok\") {\r\n                  wx.showToast({\r\n                        title: '获取手机号失败',\r\n                        icon: 'none'\r\n                  })\r\n                  return;\r\n            }\r\n            wx.showLoading({\r\n                  title: '获取手机号中...',\r\n            })\r\n            wx.login({\r\n                  success(re) {\r\n                        wx.cloud.callFunction({\r\n                              name: 'regist', // 对应云函数名\r\n                              data: {\r\n                                    $url: \"phone\", //云函数路由参数\r\n                                    encryptedData: e.detail.encryptedData,\r\n                                    iv: e.detail.iv,\r\n                                    code: re.code\r\n                              },\r\n                              success: res => {\r\n                                    wx.hideLoading();\r\n                                    //获取成功，设置手机号码\r\n                                    that.setData({\r\n                                          phone: res.result.data.phoneNumber\r\n                                    })\r\n                              },\r\n                        })\r\n                  },\r\n            })\r\n      },此处仅展示前端部分核心代码，手机号获取涉及到解密过程，需要配合云函数实现，具体的请参考完整demo注册页代码目前该接口针对非个人开发者，且完成了认证的小程序开放（不包含海外主体）。常用联系方式的校检：if (!(/^\\w+((.\\w+)|(-\\w+))@[A-Za-z0-9]+((.|-)[A-Za-z0-9]+).[A-Za-z0-9]+$/.test(email))) {\r\n                  wx.showToast({\r\n                        title: '请输入常用邮箱',\r\n                        icon: 'none'\r\n                  });\r\n                  return false;\r\n            }同理相关正则：//手机号\r\n/^[1][3,4,5,6,7,8,9][0-9]{9}$/\r\n//QQ号\r\n/^\\s*[.0-9]{5,11}\\s*$/\r\n//微信号\r\n/^[a-zA-Z]([-_a-zA-Z0-9]{5,19})+$/目前常用手机号，似乎就差10和12字段的没有了。二：发布信息页步骤条实现发布页有几个小地方值得留意：顶部的步骤条，随操作流程一直在变。步骤改变时，有个横向切换动画价格设置，使用了步进器刚刚上面之所以说这几个点，因为他们都是同出一源--vant组件此组件的使用教程可直接看对应官网https://youzan.github.io/vant...使用组件开发效率会高很多，避免重复工作，同时可以参考部分组件的写法，还是有很多值得学习的地方的。textarea小注意步骤二中备注信息那里使用了层级最高的原生组件textarea，这里有个特别使用注意项：如果下面tabbar是自己写的而非使用的自带原生的tabbar，会出现穿透现象，如下图示例：我常用的解决办法，通过动态改变textarea的聚焦状况，当点击该区域时，设置聚焦显示真实textarea，当失焦之后，展示为view层，代码如下：<view class=\"beibox\">\r\n      <view wx:if=\"{{!focus}}\" bindtap=\"focus\" >{{beizhu?beizhu:'请输入信息'}}</view>\r\n      <textarea wx:if=\"{{focus}}\" focus=\"{{focus}}\" bindblur=\"loose\" bindinput=\"beiInput\" value=\"{{beizhu}}\"></textarea>\r\n</view>data: {\r\n            beizhu:'',\r\n            focus: false //默认不聚焦\r\n      }\r\n    //点击聚焦显示textarea隐藏view\r\n      focus() {\r\n            let that = this;\r\n            that.setData({\r\n                  focus: true\r\n            })\r\n      },\r\n      //失焦隐藏textarea显示view\r\n      loose() {\r\n            let that = this;\r\n            that.setData({\r\n                  focus: false\r\n            })\r\n      },三：首页上面左图是首页的进入后的初始样式，右图是下滑之后的动态页面，关于页面的样式布局方面，使用flex可以轻松搞定，我们重点说下面这点：监控屏幕滚动实现动态响应在上图第二张示例图中，随着页面下滑，顶部分类栏也随之置顶，下方也出现了一个返回顶部按钮，实现原理：监控屏幕下滑高度，当大于我们设定的某个值时，元素进行渲染这里我们需要使用页面的一个事件处理函数：onPageScroll//监测屏幕滚动\r\n      onPageScroll: function(e) {\r\n            this.setData({\r\n                  scrollTop: (e.scrollTop) * （wx.getSystemInfoSync().pixelRatio)\r\n            })\r\n      },函数获取的是页面在垂直方向已滚动的距离（单位px），但我们页面布局使用了rpx计算，所以后面我们乘以设备像素比获取对应的rpx值在view视图层中通过wx:if或者hidden进行控制显隐，区别在于：wx:if每次隐藏都是销毁了，而hidden只是不呈现，但依旧渲染到页面，具体的使用效果，可查看视图调试处的效果。下面给个完整的返回顶部示例<view class=\"totop\" bindtap=\"gotop\" hidden=\"{{ scrollTop<500 }}\">\r\n       <image  lazy-load src=\"/images/top.png\" />\r\n</view>data: {\r\n            scrollTop: 0 //初始滚动高度为0\r\n      },\r\n        //监测屏幕滚动\r\n      onPageScroll: function(e) {\r\n          this.setData({\r\n              scrollTop: parseInt((e.scrollTop) * wx.getSystemInfoSync().pixelRatio)\r\n          })\r\n      },\r\n      //返回顶部\r\n      gotop() {\r\n            wx.pageScrollTo({\r\n                  scrollTop: 0\r\n            })\r\n      },四：详情页面小程序布局只要掌握一个flex，基本上就够了，所以这里不过多阐述样式问题，到时候如果有疑问可查看完整demo，都有注释的。因为此小程序的使用对象及功用限制，所以和完整的商城相比少了一个购物车功能，支付购买在商品详情页即完成了，这里涉及到两个点，一是下单购买，二是购买之后的通知问题。小程序内支付提现不仅仅是支付包括提现，此程序都借助了tenpay这个模块，详细介绍：https://www.npmjs.com/package...在小程序中的实例使用，可以参考之前社区之前发布的文章：10行代码实现小程序支付功能！丨实战当然，之前文章是教大家如何实现支付，关于提现流程也一样，先去看看tenpay的商户付款到余额的说明，再看一下此程序的相关代码，读一遍准能懂。发送通知此程序通知分为两类：短信通知、邮件通知使用场景：用户下单后，对卖家进行短信+邮件通知，下单后订单状态改变使用邮件通知。说一点题外话：小程序有一个自带的模板通知，在用户主动触发后7天内能推送模板信息，之前写这个程序的时候慎重考虑过，最后还是舍弃了，毕竟七天时间，不是每本书都那么畅销的。邮件只需要有一个账户即可，短信通知却是要成本的，当然效果要比邮件好，配置起来的话，难度都一样，我们就以短信为例：首先去腾讯云申请短信API:https://cloud.tencent.com/pro...按照提示操作，设置好短信签名，模板等。配置云函数新建sms云函数，代码如下：const cloud = require('wx-server-sdk')\r\n    const QcloudSms = require(\"qcloudsms_js\")\r\n    const envid = 'zf-shcud'; //云开发环境id\r\n    const appid = 140000001 // 替换成您申请的云短信 AppID 以及 AppKey\r\n    const appkey = \"abcdefghijkl123445\"\r\n    const templateId = 1234 // 替换成您所申请模板 ID\r\n    const smsSign = \"腾讯云\" // 替换成您所申请的签名\r\n    cloud.init({\r\n      env: envid,\r\n    })\r\n    // 云函数入口函数\r\n    exports.main = async (event, context) => new Promise((resolve, reject) => {    \r\n      /*单发短信示例为完整示例，更多功能请直接替换以下代码*/\r\n      var qcloudsms = QcloudSms(appid, appkey);\r\n      var ssender = qcloudsms.SmsSingleSender();\r\n      var params = [\"测试内容\"];\r\n      // 获取发送短信的手机号码\r\n      var mobile = event.mobile\r\n      // 获取手机号国家/地区码\r\n      var nationcode = event.nationcode\r\n      ssender.sendWithParam(nationcode, mobile, templateId, params, smsSign, \"\", \"\", (err, res, resData) => {\r\n          /*设置请求回调处理, 这里只是演示，您需要自定义相应处理逻辑*/\r\n          if (err) {\r\n            console.log(\"err: \", err);\r\n            reject({ err })\r\n          } else {\r\n            resolve({ res: res.req, resData })\r\n          }\r\n        }\r\n      );\r\n    })提一个小点：在有多个云环境时候，如果涉及到查询云数据库等和云环境有直接干系的操作时候，最好在cloud.init({env: envid})这里声明一下环境，否则有小几率报错。五、启动页设计启动页也算本程序一个亮点，首次进入就是一张美美的图给人一种身心愉悦之感，下面我们就详细说说这个怎么做：哪些元素？全屏背景图倒计时跳转说这个之前，大家注意一下整个页面是全屏了的，所以这里我们要配置一下页面参数：在此页面的.json中这么配置：{\r\n  \"navigationStyle\":\"custom\"\r\n}这就成功全屏了，接着我们来编写页面样式：<view class=\"contain\">\r\n     <view class=\"go\">\r\n             <button  bindtap=\"go\">跳过{{count}}s</button> \r\n     </view>\r\n     <image class=\"bg\" src=\"{{bgurl}}\"></image>\r\n</view>.contain {\r\n      width: 100%;\r\n      height: 100%;\r\n      position: relative;\r\n}\r\n.bg {\r\n      position: absolute;\r\n      left: 0rpx;\r\n      top: 0rpx;\r\n      width: 100%;\r\n      height: 100%;\r\n      z-index: -1;\r\n}\r\n.go {\r\n      position: absolute;\r\n      right: 30rpx;\r\n      top: 150rpx;  \r\n      z-index: 9;\r\n}\r\n.go button {\r\n      font-size: 28rpx;\r\n      letter-spacing: 4rpx;\r\n      border-radius: 30rpx;\r\n      color: #000;\r\n      background: rgba(255, 255, 255, 0.781);\r\n       display: flex;\r\n      justify-content: center;\r\n      align-items: center;\r\n      text-align: center;\r\n      width: 160rpx;\r\n      height: 60rpx;\r\n}样式快速搞定，再来说说js部分。倒计时功能：countDown: function() {\r\n            let that = this;\r\n            let total = 3;//倒计时总数3秒\r\n            this.interval = setInterval(function() {\r\n                  total > 0 && (total--, that.setData({\r\n                        count: total\r\n                  })), 0 === total && (that.setData({\r\n                        count: total\r\n                  }), wx.switchTab({\r\n                        url: \"/pages/index/index\"\r\n                  }), clearInterval(that.interval));\r\n            }, 1e3);\r\n      },背景图实现有两种办法，第一是本地路径，第二是引用远程地址（可通过接口动态改变）第一种好处是直接使用本地图片，加载速度快，第二种可以随时更换启动图，两种办法都试过了，最终我建议还是采用第一种办法，使用本地图片，如果使用远程地址，首次进入会出现短时间白屏，体验不好，当然，你也可以想办法把图片压缩再压缩，那就不存在加载慢了，但分辨率又成了个问题，所以具体如何使用，还是根据产品需求。总结纸上得来终觉浅，绝知此事要躬行，以上总结的是开发此程序中我认为遇到的典型问题，实践过程中肯定会有更多有意思的问题的出现，“面向百度”编程是一个方面，但我更建议“面向官方文档”，很多问题其实官方文档中都有很详细的说明和代码示例，如果阅读文档颇感费力，我建议你该静下心来，先熟悉下html,css,javascript相关内容，到时候再回过头来看你会发现“原来如此”。源码地址https://github.com/TencentCloudBase/Good-practice-tutorial-recommended"}
{"title": "微信小程序开发系列教程第七章：编辑名片页面开发 ", "author": "admin", "time": "2016-10-12 22:14", "abstract": "博卡君对于“应用号的最终形态”与“怎样将一个「服务号」改造成为「小程序」”的话题上，有着自己的独特的理解。他想要用第三方工具的实例，来演示开发过程。今天，他为我们带来《微信小程序编辑名片页面开发》的内 ...", "content": "编辑名片有两条路径，分为新增名片流程与修改名片流程。用户手填新增名片流程：首先跳转到我们的新增名片页面 1 需要传递用户的当前 userId，wx.navigateTo 带值跳转。Manual 为 true 设置用户走的是新增路线。新增名片页面 1 基本布局如下：取到 userId。使用微信自带的 input 组件验证也非常好用，如 maxLength 属性，可以限制用户输入长度，如我这的姓名长度是最大 5 位，直接数字 5 即可。也可以自定义一些验证效果，具体可以根据需求进行一些验证配置，取到用户输入的值，进行操作。这里绑定了自带的模态框提示组件。其中 modalHidden2 是模态框开关。另外 proptText 是需要提示的内容。即使很多输入框也支持数据动态改变，非常方便。实际效果，非常快捷，比以前省去很多事情，编写小程序，发现最大的好处可能就是我们不必去考虑一系列兼容性问题。最后还有个头像上传图片，测试了下目前上传到后台服务器还有点问题，应该是内测版本不太完善导致吧。设置的直接是背景图片。提交表单与跳转。提交表单使用的是自带的 bindsubmit 事件组件，在 button 组件上添加 formType=”submit” 即可，还有点需注意的是使用表单提交功能时 input 需加上 name 属性，这个传递方式是以键值对的形式传递的。这时候跳转到编辑页 2 页面，这个页面是根据用户填写的手机号码识别到匹配的公司，页面非常简单，一个数据循环而已，单选框日后可能还需要美化一下。同样也是一些数据绑定以及验证效果。实际渲染效果可以看到。这个和第一个编辑页面逻辑基本不相上下，一些基本验证与提交，这里就讲到前面两步骤即可，编辑页面3也是同理，这里不再过多啰嗦。修改名片流程效果图与需求，修改名片是一次性把以前填写的个人信息全部渲染出来，供用户来改动：名片图片模块，上传图片暂时还有点问题，这里就是模仿了个跳转组件，比较建议需要跳转的页面还是使用 wx.navigateTo 控制好一点，wx.navigateTo 提供了给我们不同的 3 个跳转路由，封装的都很好，而且跳转页面很多牵连到传值之类的，可以达到统一管理也可以避免一些看不到的 bug 吧，总之还是根据业务需求来定：姓名手机必填模块：个人信息模块，直接循环（block）出来：Onload 时我们请求必填与选填数据：* requiredGroup 必填中文信息* notRequiredGroup 选题中文信息* requiredGroupEn 必填英文信息* notRequiredGroupEn 选题英文信息```//请求名片对应的公司的中文信息的属性组数据，分为必填和选填//选题项变量以 no 开头requester.getOfflineCardInfoGroupFields(userId, cardId,function (res) {//debuggervar userName = res.card.userName;var mobile = res.card.mobile;var requiredGroup = res.requiredGroupCh;var notRequiredGroup = res.notRequiredGroupCh;var requiredGroupEn = res.requiredGroupEn;var notRequiredGroupEn = res.notRequiredGroupEn;var reqLen = requiredGroup.fields.length;var nreqLen = notRequiredGroup.fields.length;var reqLenEn = requiredGroupEn.fields.length;var nreqLenEn = notRequiredGroupEn.fields.length;self.setData({userName: userName,mobile: mobile,requireFields: requiredGroup.fields,notRequireFields: notRequiredGroup.fields,requireFieldsEn: requiredGroupEn.fields,notRequireFieldsEn: notRequiredGroupEn.fields,l1: reqLen,l2: nreqLen + reqLen,l3: reqLenEn + nreqLen + reqLen});self.forceUpdate();}, function (code, msg) {console.info(\"code=\" + code + \"&msg=\" + msg);});```中英文信息必填与选填渲染：这里表单提交数据转换有点复杂（大家根据业务需求来做，不必花时间研究这里的方法），获取的是数组，按照后台需要的数据格式进行转换传递过去。今天再回去理下首页 A、B、C 定点跳转功能实现方法。首先是右边小索引布局以及数据绑定，数据绑定和名片夹列表上的字母一样，该字母下面有名片则渲染出来，没有则不需要渲染，id同样是当前字母与右边显示的内容一样：数据 sort，和 group.name 数据一样：这里是因为 # 不支持设为 id（就是 id=”#”），故而进行了一个转化。点击事件：获取到当前 ID，以及绑定数据 toView 为当前 ID。首先名片列表，名片上的字母索引都在 scroll-view 里面，这个 scroll-view 必须设置好固定的高度，设置成 100% 与 100vh 是无效的，y 轴的滚动开关打开，scroll-into-view 需要跳转到它子元素的 id 上。可以看下：这个 group.name==sortmsg，等于就是 A==A,B==B 同理。在这里如顶部有些菜单栏的话，你就要注意好布局了，不然会出现向下偏移这个菜单栏的高度，其实你只要和字母索引同级下即可避免此问题（这里的顶部菜单以模板分离出去了，分离模板的时候需注意下，需要在这里绑定模板的一些数据会出现失效，具体没有继续深入研究下去）。跳转功能基本实现（ohter 就是 # 底部）。"}
{"title": "小程序分享海报的坑 ", "author": "Rolan", "time": "2019-7-18 00:50", "abstract": "UI小哥给了一张UI图，让我实现小程序的分享海报   踩坑如下：  canvas绘制文字自动换行 canvas绘制文字，首行缩进 canvas剪切圆形头像  一、canvas 绘制文字，自动换行 因为canvas.fillText绘制文字是没用自动换行的 ...", "content": "UI小哥给了一张UI图，让我实现小程序的分享海报\r\n\r\n\r\n踩坑如下：\r\n\r\ncanvas绘制文字自动换行\r\ncanvas绘制文字，首行缩进\r\ncanvas剪切圆形头像\r\n\r\n一、canvas 绘制文字，自动换行\r\n因为canvas.fillText绘制文字是没用自动换行的功能的，所以需要自己封装个函数来实现。\r\ncanvas有个APIctx.measureText(string str).width可以获取字符串的像素长度\r\n当一行文字的像素长度超过画布的长度时，就可以另起一行重新绘制文字\r\n/*\r\n\tlineWidth:一行文字的总长度\r\n\tstr:是要写入的字符串\r\n\tinitX:初始时，文字距离画布边缘的距离\r\n\tcanvasWidth:画布的宽度\r\n\tlineHeight:是行高\r\n*/\r\nlet lineWidth = 0;\r\nfor(let i=0;i<str.length;i++){\r\n    lineWidth += ctx.measureText(str[i]).width;//每次增加一个字符的像素长度\r\n    if(lineWidth>canvasWidth-2*initX){\r\n        //减去两个initX是想在文字两边都有相同距离的空白\r\n        ctx,fillText(str.substr(0,i),initX,initY);\r\n        initY+=lineHeight;\r\n        str = str.str.substr(i);\r\n        i = -i;\r\n        lineWidth;\r\n\t}\r\n    //如果绘制到字符串的末尾了，还没超过画布的宽度\r\n    if(i==str.length-1){\r\n        ctx.fillText(str.substr(0,i+1),initX,initY);\r\n    }\r\n}\r\n复制代码二、canvas首行缩进\r\n因为canvas没有首行缩进的属性，只能是，绘制的时候，向右偏移两个字符的长度\r\n/*\r\n\tindent:布尔值，是否缩进\r\n\tindentWidth:缩进的像素宽度\r\n*/\r\nlet indent = true;\r\nlet indentWidth = 0;\r\nfor(let i=0;i<str.length;i++){\r\n    lineWidth += ctx.measureText(str[i]).width;\r\n    if(indent && i==1){\r\n        indentWidth = lineWidth;\r\n    }\r\n    if(indent && lineWidth>canvasWidth-2*initX-indentWidth){\r\n        ctx.fillText(str.substr(0,i),initX+indentWidth,initY);\r\n        initY+=lineHeight;\r\n        lineWidth=0;\r\n        indent = false;\r\n        str = str.substr(i);\r\n        i =-1;\r\n    }\r\n}\r\n复制代码小总结，将自动换行和首行缩进，封装成函数如下\r\n/*\r\n\tctx：wx.createCanvasContext获取的画布上下文\r\n\tinitX:距离画布左边缘的距离\r\n\tinitY:距离画布上部的距离\r\n\tstr:要绘制的字符串\r\n\tlineHeight:行高\r\n\tindent:布尔值，是否要首行缩进\r\n*/\r\ncanvasTextAutoLine(ctx,canvasWidth,str,initX,initY,lineHeight,indent=false){\r\n    let lineWidth =  0;\r\n    let indentWidth=0;\r\n    for(let i=0;i<str.length;i++){\r\n        lineWidth += ctx.measureText(str[i]).width;\r\n        if(indent && i==1){\r\n            indentWidth = lineWidth;\r\n        }\r\n        if(indent && lineWidth>canvasWidth-2*initX-indentWidth){\r\n            ctx.fillText(str.substr(0,i),initX+indentWidth,initY);\r\n            initY+=lineHeight;\r\n            lineWidth=0;\r\n            indent = false;\r\n            str = str.substr(i);\r\n            i =-1; //下次循环i会加1,所以下次循环就是1\r\n        }\r\n        if(lineWidth>canvasWidth-2*initX){\r\n            ctx.fillText(str.substr(0,i),initX,initY);\r\n            initY+=lineHeight;\r\n            str=str.substr(i);\r\n            i=-1;\r\n            lineWidth=0; \r\n        }\r\n        if(i==str.length-1){\r\n            ctx.fillText(str.substr(0,i+1),initX,initY);\r\n        }\r\n    }\r\n    return initY;\r\n}\r\n复制代码三、canvas剪切出圆形的头像\r\ncanvas的APIctx.clip()可以剪切图形，使用如下\r\n//1. 在使用clip()要先将之前绘制的图形保存\r\nctx.save();\r\n//2. 绘制你要剪切的图形\r\nctx.arc(25,25,25,0,Math.PI*2);\r\n//3. 剪切\r\nctx.clip();\r\n//4. 在剪切的范围内绘制图形，超过这个范围的不显示\r\nctx.drawImage(headImg,0,0,25,25);\r\n//5. 绘制完后，释放之前保存的图形\r\nctx.restore();\r\n复制代码结语\r\n作者：胡志武\r\n时间：2019/7/17\r\n本人大二，想找个前端实习生的工作。求职中。。。"}
{"title": "微信小程序支付功能全流程实践 ", "author": "Rolan", "time": "2019-7-25 00:13", "abstract": "微信小程序为电商类小程序，提供了非常完善、优秀、安全的支付功能。在小程序内可调用微信的API完成支付功能，方便、快捷。小程序开发者在开发小程序时，支付流程是必然要接触到，今天胡哥就小程序支付的全流程为大 ...", "content": "微信小程序为电商类小程序，提供了非常完善、优秀、安全的支付功能。在小程序内可调用微信的API完成支付功能，方便、快捷。小程序开发者在开发小程序时，支付流程是必然要接触到，今天胡哥就小程序支付的全流程为大家一一细说，让小伙伴能快速得掌握小程序支付能力，避免踩坑！知己知彼，方能百战不殆 - 小程序支付流程图举个栗子:chestnut:：某用户小明在某电商小程序上购买一块肥皂，从浏览、下单到支付经历了什么样的过程呢？打开电商小程序，搜索浏览到某雕肥皂，点击查看详情后，发现大小、丝滑程度都很合适，点击直接下单wx.login获取用户临时登录凭证code，发送到后端服务器换取openId在下单时，小程序需要将小明购买的商品Id，商品数量，以及小明这个用户的openId传送到服务器服务器在接收到商品Id、商品数量、openId后，生成服务期订单数据，同时经过一定的签名算法，向微信支付发送请求，获取预付单信息(prepay_id)，同时将获取的数据再次进行相应规则的签名，向小程序端响应必要的信息(必须字段信息将在下文进行详细说明)小程序端在获取对应的参数后，调用wx.requestPayment()发起微信支付，唤醒支付工作台，进行支付小结进行微信支付，在小程序端我们主要做三件事：注：服务端调用统一下单API、签名算法不再本次分享讨论范围内，请期待胡哥的另外一次分享。使用** wx.login **获取临时登录凭证code,发送到后端获取openIdwx.login({\r\n  success (res) {\r\n    if (res.code) {\r\n      // 发起请求，换取openId\r\n      wx.request({\r\n        url: '',\r\n        data: {\r\n          code: res.code\r\n        }\r\n      })\r\n    }\r\n  }\r\n})\r\n复制代码将** openId **以及相应需要的商品信息发送到后端，换取服务端进行的签名等信息wx.request({\r\n  url: '',\r\n  data: {\r\n    openId: '',\r\n    num: 1,\r\n    id: '111'\r\n  }\r\n})\r\n复制代码接收返回的信息（必须要包含发起微信支付** wx.requestPayment的参数 **），发起微信支付wx.requestPayment({\r\n  // 时间戳\r\n  timeStamp: '',\r\n  // 随机字符串\r\n  nonceStr: '',\r\n  // 统一下单接口返回的 prepay_id 参数值\r\n  package: '',\r\n  // 签名类型\r\n  signType: '',\r\n  // 签名\r\n  paySign: '',\r\n  // 调用成功回调\r\n  success () {},\r\n  // 失败回调\r\n  fail () {},\r\n  // 接口调用结束回调\r\n  complete () {}\r\n})\r\n复制代码注意：以上信息中 timeStamp 、 nonceStr 、 prepay_id 、 signType 、 paySign 各参数均建议必须都由服务端返回（这样会尽最大可能性保证签名数据一致性），小程序端不做任何处理基于Taro的微信支付实例import Taro, { Component } from '@tarojs/taro'\r\nimport { View, Text, Button } from '@tarojs/components'\r\nimport './index.scss'\r\n\r\nexport default class Index extends Component {\r\n\r\n  config = {\r\n    navigationBarTitleText: '首页'\r\n  }\r\n\r\n  componentWillMount () { }\r\n\r\n  async componentDidMount () { \r\n  }\r\n\r\n  componentWillUnmount () { }\r\n\r\n  componentDidShow () { }\r\n\r\n  componentDidHide () { }\r\n\r\n  /**\r\n   * sendOrderInfo()\r\n   * @description 提交订单信息，获取支付凭证，唤起支付\r\n   */\r\n  async sendOrderInfo () {\r\n    // 获取临时登录凭证code\r\n    let codeData = await Taro.login()\r\n    // 换取openId\r\n    let openId = ''\r\n    if (codeData.code) {\r\n      let res = await Taro.request({\r\n        // 定义的后端换取openId的接口\r\n        url: 'https://www.justbecoder.com/getLogin',\r\n        data: {\r\n          code: codeData.code\r\n        }\r\n      })\r\n      if (res && res.code === 0) {\r\n        openId = res.openId\r\n      }\r\n    }\r\n    // 发送openId以及对应的商品信息\r\n    let data = await Taro.requrest({\r\n      url: 'https://www.justbecoder.com/createdOrder',\r\n      data: {\r\n        openId,\r\n        // 实际情况的商品数量\r\n        num: 1,\r\n        // 实际情况的商品Id\r\n        id: 111,\r\n      }\r\n    })\r\n    // code === 0 表示提交订单成功，返回需要的签名信息等\r\n    if (data && data.code === 0) {\r\n      let {\r\n        timeStamp,\r\n        nonceStr,\r\n        prepay_id,\r\n        signType,\r\n        paySign\r\n      } = data.payInfo\r\n      // 唤起支付，按小程序要求格式发送参数\r\n      let payData = await Taro.requestPayment({\r\n        timeStamp,\r\n        nonceStr,\r\n        package: 'prepay_id=' + prepay_id,\r\n        signType,\r\n        paySign\r\n      })\r\n      if (payData && payData.errMsg === 'requestPayment:ok') {\r\n        Taro.showModal({\r\n          title: '操作提示',\r\n          content: '支付成功',\r\n          showCancel: false,\r\n          confirmText: '确定'\r\n        })\r\n      } else {\r\n        Taro.showModal({\r\n          title: '操作提示',\r\n          content: '支付失败，请重新尝试',\r\n          showCancel: false,\r\n          confirmText: '确定'\r\n        })\r\n      }\r\n    }\r\n  }\r\n\r\n  render () {\r\n    return (\r\n      <View className='index'>\r\n        <Button onClick={this.sendOrderInfo}>立即下单</Button>\r\n      </View>\r\n    )\r\n  }\r\n}\r\n复制代码效果图结语在实际项目操作中，大家把接口换成自己的可用接口即可。后记以上就是胡哥今天给大家分享的内容，喜欢的小伙伴记得** 收藏 、 转发 、点击右下角按钮 在看 **，推荐给更多小伙伴呦，欢迎多多留言交流...胡哥有话说，一个有技术，有情怀的胡哥！京东开放平台首席前端攻城狮。与你一起聊聊大前端，分享前端系统架构，框架实现原理，最新最高效的技术实践！"}
{"title": "破解网易易盾在小程序上成功购票的过程 ", "author": "Rolan", "time": "2019-8-5 00:42", "abstract": "盘点背景经朋友介绍接触到这个项目，目的就是要抢到门票:ticket:，最大的问题在于什么呢，有微信小程序版本和IOS版本，都加入了网易易盾的滑块验证。“黑人问号”乘以2都不止，起码是平方吧:joy:。微信本身就有比较 ...", "content": "盘点背景经朋友介绍接触到这个项目，目的就是要抢到门票:ticket:，最大的问题在于什么呢，有微信小程序版本和IOS版本，都加入了网易易盾的滑块验证。“黑人问号”乘以2都不止，起码是平方吧:joy:。微信本身就有比较高的壁垒了，what？还有网易易盾小程序滑动验证，一开始都是拒绝的，最后抵不过商务游说，只是答应研究研究，并没有说要接这单。怎奈一切入了怎么好轻易言弃呢？坚持就是胜利:v:，成功出票。结果直接上图，当然有录屏鉴于有微信小程序的名字和个人资料信息 录屏自留，截屏马赛克处理。PS：界面素颜有点儿丑但是很实在 至少不会认为是“乔碧萝殿下 老阿姨”所用技术和工具Airtest 是一款跨平台的UI自动化测试框架，基于图像识别原理，适用于游戏和App。 python、 Flask 、 webdriver 、 mitmProxy 、 openCV 、 mongoDB 、 Postman 、 Charles过程首先之前有了解过web页面可以通过webdriver来做自动化的操作，但是这是微信小程序移动端呀？这条路走不通了那么我想想有没有移动端做自动化测试的与webdriver类似的，按照这个思路找到了 Airtest ，「what？用网易的自动化测试工具来破网易易盾 以子之矛攻子之盾」 后来经过实操不好用！不好用！不好用！无论是苹果和安卓都是两种模式 一、通过截图自动对比后做出响应速度很慢 内容相识识别效果不理想（如：列表中按钮或者相同图标）；二、类似于文档选择器（DOM）选择器层级很深完全每个节点每个节点定位的 不准确经常定位不到元素报错 MD好像还真没辙了，NO 不是这样的画风呀又想能不能绕过易盾小程序呢，怎么样直接发起保存订单的请求呢，我们只能出卖自己的个人信息 手动下单抓包现在的问题就在于解决validate和Uuid两个参数了首先去易盾官方文档找易盾小程序接入教程以及研究易盾小程序调起、验证、退出机制，得出结论validate就是易盾验证通过后回调传递给宿主小程序的参数 Uuid暂时不得而知；破解宿主小程序拿到源码通过以上源码我们很容易找出两个参数的又来模拟请求尝试跑通流程。诸参数就位，ok那么我们就完整的来跑一下流程，用postMan模拟发起请求，试验抢票的可行性。当然最终的结果是完美的证明。但是中间的过程 出现的问题，只有做过系统对抗的伙伴知道的。系统设计首先通过代理拿到微信的认证信息上传游客照片（系统有人脸识别）、保存游客信息(有个参数必须看源码才知道如何生成)获取网易易盾验证信息（核心之处，破解方式不能完全公开，需要了解的可以文末加微信咨询）抢票开发完成实战检验 首先拿不用抢购的门票，通过！每日定时限量票，通过！事先开启了录屏 （小视频只有自己看，不公开目标小程序）项目总结和思考关键技术点 采用中间人攻击方式获取微信认证信息；易盾的破解；小程序源码抓取和参数分析；问题点：平台对微信账号的限制购买规则；易盾校验信息通过率偏低；人脸识别；抢票逻辑和业务流程先录入一批游客信息获取易盾验证信息抢票时先取未购票前5人作为一组一并下单，成功后，标记为已购票游客，可以自动进行下一组抢票优化点和方向【节省时间、避免系统限制】先录入游客信息；先得到易盾验证信息，到点直接发起提交请求；多线程、自动组单、自动抢购IP代理池自动切换设备信息池，特别是易盾有基于大数据机器学习微信账号池、微信养号flask、微信小程序破解、移动端中间人攻击代理、AriTest、PC上自动操作滑块验证每一个都可以作为单独一篇文章来细讲，犹豫安全和篇幅的原因本文只公布部分截图和分享技术点逻辑思维，有能力的伙伴可能看后也能复刻出，以上仅作为研究学习使用，并无恶意，请大家合理学习使用，犹豫滥用引发的任何问题和纠纷，作者不承担任何法律责任个人微信 欢迎来撩，请添加如下微信二维码，烦请备注 most_wanted抢票"}
{"title": "撸一个微信小程序记事本备忘录-随微记 ", "author": "Rolan", "time": "2019-8-12 00:37", "abstract": "废话不多说了，目的直接点微信上记录一些资料(比如公司信息以及开发票等)，方便查看可以随时分享出来，可以生成图片海报做一些工具（后续开放）最后总结就是弄它，随微记是自己想的，页面也是自己布局，海报的配置可 ...", "content": "废话不多说了，目的直接点微信上记录一些资料(比如公司信息以及开发票等)，方便查看可以随时分享出来，可以生成图片海报做一些工具（后续开放）最后总结就是弄它， 随微记 是自己想的，页面也是自己布局，海报的配置可能也有自己的喜好存在目前版本为 V1.0.0 ，在此篇文章不会有代码的东西认知(需要改善)：没有各种的app好用没有手机自带备忘录的好用微信小程序技术微信小程序原生apiTaroColorUi组件库功能列表还有未完成的功能后续更新界面介绍遇到问题editor\r\n云开发云开发数据主要的存储是用户的列表以及用户笔记本和笔记的数据本来想用存图片，第一版本的时候遇到了图片size限制的问题，因此近期改版为上传至阿里OssNode + koa + mysql 服务 koa-swagger-decorator自动生成api文档 文字笔记海报配置 图文笔记海报配置 分享海报配置 用户同步数据 模板使用情况记录 分享日志记录 https域名部署 node项目部署pm2进程监控 图片删除任务更新 后台session登录 mysql使用 后台未完成功能有点多，在此不列了\"dependencies\": {\r\n    \"@babel/polyfill\": \"^7.4.4\",\r\n    \"axios\": \"^0.19.0\",\r\n    \"debug\": \"^4.1.1\",\r\n    \"koa\": \"^2.7.0\",\r\n    \"koa-bodyparser\": \"^4.2.1\",\r\n    \"koa-convert\": \"^1.2.0\",\r\n    \"koa-generic-session\": \"^2.0.1\",\r\n    \"koa-json\": \"^2.0.2\",\r\n    \"koa-logger\": \"^3.2.0\",\r\n    \"koa-onerror\": \"^4.1.0\",\r\n    \"koa-redis\": \"^4.0.0\",\r\n    \"koa-router\": \"^7.4.0\",\r\n    \"koa-static\": \"^5.0.0\",\r\n    \"koa-swagger-decorator\": \"^1.5.16\",\r\n    \"koa-views\": \"^6.2.0\",\r\n    \"moment\": \"^2.24.0\",\r\n    \"mysql\": \"^2.17.1\",\r\n    \"pug\": \"^2.0.3\"\r\n  },\r\n  \"devDependencies\": {\r\n    \"@babel/cli\": \"^7.5.5\",\r\n    \"@babel/core\": \"^7.5.5\",\r\n    \"@babel/parser\": \"^7.5.5\",\r\n    \"@babel/plugin-proposal-class-properties\": \"^7.5.5\",\r\n    \"@babel/plugin-proposal-decorators\": \"^7.4.4\",\r\n    \"@babel/plugin-proposal-optional-chaining\": \"^7.2.0\",\r\n    \"@babel/plugin-transform-object-assign\": \"^7.2.0\",\r\n    \"@babel/plugin-transform-runtime\": \"^7.5.5\",\r\n    \"@babel/preset-env\": \"^7.5.5\",\r\n    \"@babel/register\": \"^7.5.5\",\r\n    \"cross-env\": \"^5.2.0\",\r\n    \"install\": \"^0.13.0\",\r\n    \"nodemon\": \"^1.19.1\",\r\n    \"npm\": \"^6.10.2\"\r\n  }\r\n复制代码路由配置const tag = tags(['WeChat']);\r\n@prefix('/api/user')\r\nexport default class WechatRouter {\r\n\t@request('post', '/authorize')\r\n  @summary('微信授权登录')\r\n  @description('登录之后返回sesscion和openid')\r\n  @tag\r\n\t@body({\r\n\t\tcode: { type: 'string', required: true, default: '', description: '小程序code' },\r\n\t})\r\n\tstatic async authorize(ctx) {\r\n\t\tlet { code } = ctx.request.body;\r\n    let str = ctx.request.body?.code;\r\n    // console.log('开始访问请求参数2', APPID, APPSECRET, str)\r\n    let res = await getOpenId(code);\r\n    ctx.body = new SuccessModal(res);\r\n\t}\r\n}\r\n复制代码资源链接koa-generatorkoakoa-swagger-decorator后续开发后续后开发围绕微信和备忘录的一系列的工具或者功能，欢迎指出不足和功能改善，或者你想要的功能"}
{"title": "uni-app微信小程序接入人脸核身SDK ", "author": "Rolan", "time": "2019-8-19 00:37", "abstract": "这几天使用uni-app开发某银行的一个微信小程序，需要集成接入腾讯云的人脸核身SDK，如上图所示，记录下整合接入过程及踩的一些坑，帮助后面需要的朋友们。关于uni-app接入人脸核身SDK有不懂的地方可以在下面提问，看 ...", "content": "这几天使用uni-app开发某银行的一个微信小程序，需要集成接入腾讯云的人脸核身SDK，如上图所示，记录下整合接入过程及踩的一些坑，帮助后面需要的朋友们。关于uni-app接入人脸核身SDK有不懂的地方可以在下面提问，看到会及时回复。申请服务不是所有的企业都能够申请的，需要符合以下行业要求的客户才能申请政务：政府机构或事业单位金融：银行、保险医疗：公立医疗机构运营商：电信运营商教育：公立教育机构交通：航空、客运、网约车、交通卡、共享交通、轨道交通、租车旅游：酒店物流：快递、邮政、物流由于SDK会调用小程序原生的 wx.startFacialRecognitionVerify 方法，所以总共得申请2个服务SDK服务： 申请人脸核身服务小程序： 查看申请流程 （需要发送邮件申请，使用该服务的小程序的appid，后面开发也是用的这个）重要的事情说3遍以上这2个服务都需要申请，缺一不可。以上这2个服务都需要申请，缺一不可。以上这2个服务都需要申请，缺一不可。下载SDK由于不是我申请的，所以怎么下载我也不知道，听群里的人说的是SDK腾讯云下发给客户的。SDK目录结构SDK接入参考腾讯云文档的接入方法： https://cloud.tencent.com/document/product/1007/31071文档是针对原生小程序写的，所以页面引入的方法有所不同由于uni-app不支持直接引入小程序的原生页面，所以这里能想到的就是将它当作成一个微信小程序的组件，然后uni-app的页面引入这个组件解压引入SDK在uni-app项目中新建 wxcomponents 目录，将SDK解压后放到该目录pages.json 中 globalStyle 中全局引入小程序的组件，注意引用的路径\"usingComponents\": {\r\n  \"verify-mpsdk\": \"/wxcomponents/verify_mpsdk/index/index\"\r\n}新建人脸核身页面pages 中新建人脸核身的页面 face (名字可以随意，根据自己的需要起名)，pages.json 中配置页面face 页面中引入 verify-mpsdk 组件最终的人脸核身的页面访问就是 /pages/face/face初始化SDK在需要的页面初始化SDK，如有个页面需要点击按钮进行人脸核身，就在这个页面进行初始化。这个直接照着文档 快速入门 中的来就行了，这里就直接使用uni-app默认的 index 页面，适当修改下即可，大概代码如下：<template>\r\n  <view class=\"content\">\r\n    <button type=\"primary\"\r\n      @tap=\"gotoVerify\">\r\n      进入人脸核身\r\n    </button>\r\n  </view>\r\n</template>\r\n\r\n<script>\r\n    export default {\r\n        data() {\r\n            return {\r\n                BizToken: ''\r\n            }\r\n        },\r\n        onLoad() {\r\n            // 初始化慧眼实名核身组件\r\n            const Verify = require('@/wxcomponents/verify_mpsdk/main.js')\r\n            Verify.init()\r\n        },\r\n        methods: {\r\n            // 单击进入人脸核身按钮时，触发该函数\r\n            gotoVerify () {\r\n                this.BizToken = '' // 这里需要我们去客户后端调用DetectAuth接口获取BizToken\r\n                // 调用实名核身功能\r\n                wx.startVerify({\r\n                        data: {\r\n                            token: this.BizToken // BizToken\r\n                        },\r\n                        success: (res) => { // 验证成功后触发\r\n                                // res 包含验证成功的token, 这里需要加500ms延时，防止iOS下不执行后面的逻辑\r\n                                setTimeout(() => {\r\n                                    // 验证成功后，拿到token后的逻辑处理，具体以客户自身逻辑为准\r\n                                    console.log(res)\r\n                                }, 500)\r\n                        },\r\n                        fail: (err) => {  // 验证失败时触发\r\n                                // err 包含错误码，错误信息，弹窗提示错误\r\n                                setTimeout(() => {\r\n                                        console.log(err)\r\n                                        wx.showModal({\r\n                                            title: \"提示\",\r\n                                            content: err.ErrorMsg,\r\n                                            showCancel: false\r\n                                        })\r\n                                }, 500)\r\n                        }\r\n                })\r\n            }\r\n        }\r\n    }\r\n</script>注意下这里的 BizToken ,需要调用后端服务接口来获取，需要后端的同学调用腾讯云提供的 DetectAuth 来返回前端需要的 BizToken ，调试开发阶段我们可以先通过腾讯云提供的工具API 3.0 Explorer直接来获取这个 BizToken 如果服务申请成功后控制台一般能找到 SecretId ， SecretKey ， RuleId 注意 Endpoint 和 Region 选择的地区得保持和申请时选择的地区一致。填写完成后点击 在线调用 中的 发送请求 按钮，如果填的都对的话返回信息里面会有 BizToken 拿到 BizToken 后就可以直接使用了，修改下上面的代码：xxxxxxxxxxxxxxxxx就是拿到的 BizTokenthis.BizToken = 'xxxxxxxxxxxxxxxxx' // 这里需要我们去客户后端调用DetectAuth接口获取BizToken开发调试上面都做完后就可以进行调试了需要先在项目中 manifest.json 中配置上小程序的appid，这个appid就是上面 申请服务 中的appid，不然无法开启调试。然后运行到微信开发工具（这里就不多说了），如果提示不是开发人员，就让该appid的管理员将你加到开发组里面就行了。运行成功后点击开发者工具的真机调试，扫描二维码开启真机调试模式。接下来就是踩坑了，会出现各种问题。踩坑及解决方法Component is not found in path这里开发者工具里面都是显示正常的，不会报这个错，手机扫码进入调试后控制台会出现这个报错，提示组件找不到，但是我们的路径都是对的，Component is not found in path \"wxcomponents/verify_mpsdk/index/index\" 问题出在这里将 verify_mpsdk 当成自定义组件了，小程序自定义组件引入的时候需要在文件JSON中指定 \"component\": true 找到 wxcomponents\\verify_mpsdk\\index\\index.json 文件，加入 \"component\": true 即可重新开启调试扫码后上面的报错就没了。 navigateTo:fail page点击按钮调用 gotoVerify 后会报一个页面找不到的错navigateTo:fail page \"verify_mpsdk/index/index?isNotice=false\" is not found SDK默认的是跳转验证页面的地址是 verify_mpsdk/index/index ，文档找了半天也没找到相应的配置地址，最后在SDK里面搜索找到了这个地址。所以只需要把这个地址改成我们所需要的地址就行了。找到 wxcomponents\\verify_mpsdk\\main.js ，里面搜索 verify_mpsdk/index/index ,找到后修改成上面 人脸核身页面 的地址 pages/face/face 保存后重试就能跳转到人脸核身的页面了。无操作、无报错大坑进入人脸核身的页面后会发现啥操作都没，控制台也没报错，一度认为我自己弄的有问题，搞了好久也没弄好，也提了个工单（腾讯云工单反馈率还是很快的，几分钟后就有人回复了，这点赞一个），将代码和相关操作在工单里描述了下，对方也觉得的没问题，按照快速入门的代码应该是没问题的，对方也没找到啥问题，就让我加了一个腾讯云慧眼小助手的微信，本想着下午加人家看看啥问题的，中午吃完饭闲着的时候将SDK里面的文件都格式化后终于在 index.js 里面找到问题所在了。wxcomponents\\verify_mpsdk\\index\\index.js 文件中有个 onLoad 生命周期，正常原生微信小程序进入到这个页面的时候会执行 onLoad 里面的代码，但是我们上面将这个SDK当作是一个自定义组件了，在uni-app中组件是不存在 onLoad 这个生命周期的，这个是页面所属的生命周期。找到问题所在就好解决了，我们可以在人脸核身的页面 pages/face/face 手动执行 onLoad 修改下 pages/face/face 的代码，如下：<template>\r\n  <view class=\"face\">\r\n    <verify-mpsdk ref=\"verifyMpsdk\"></verify-mpsdk>\r\n  </view>\r\n</template>\r\n\r\n<script>\r\n    export default {\r\n        data() {\r\n            return {\r\n                \r\n            }\r\n        },\r\n        onLoad(i) {\r\n            // 页面onLoad的时候手动调用\r\n            this.$refs.verifyMpsdk.onLoad(i)\r\n        }\r\n    }\r\n</script>保存后重试，就能正常显示了SDK图片异常点击快速验证进入下一步及后面的步骤的时候发现，页面的图片都挂掉了不显示，一开始我一直用的真机调试，页面上也不会出现破图，控制台也不会报图片异常的错误，导致我不知道怎么进行拍摄身份证，以为会自动识别身份证然后自动下一步，最后在开发者工具里面跑了一遍才知道是图片找不到了，然后拍照的图片按钮自然也就显示不了了。最后在SDK里面搜索 /verify_mpsdk/images ，在下面文件中找到关键词，wxcomponents\\verify_mpsdk\\templates\\ocr\\ocr.wxml 既然这种形式导致运行的时候图片找不到，我们可以把SDK所用的图片都复制到项目的 static目录里在 static 中新建 verify_mpsdk 目录，将SDK中的图片即 wxcomponents\\verify_mpsdk\\images 复制到 static\\verify_mpsdk 中，最终形成以下目录形式最后将 wxcomponents\\verify_mpsdk\\templates\\ocr\\ocr.wxml 中的 /verify_mpsdk/images 批量替换成/static/verify_mpsdk/images 后重试即可，然后就都正常了。完整流程最后用真机调试完整跑一把备注：如果最上面的 wx.startFacialRecognitionVerify 服务没有申请到此时点击下一步的会弹出一个无权限的弹窗无法进行下一步这里就是活体人脸检测了，需要将脸对准框框，点击开始后需要读几个数字，最后验证通过后会回到之前的页面（调用gotoVerify()方法的页面），验证成功后，会拿到一个 BizToken ，可以在 wx.startVerify 回调函数 success 中打印自行查看。拿到 BizToken 后可以调用后端的接口，后端通过调用  GetDetectInfo 接口获取并返回本次核身的详细信息，包括身份证上的信息和身份证证图片等信息。前端拿到这些信息后根据自己的程序需要做处理。结语整合过程中遇到不少问题，百度加google也找不到相关的详细信息，人脸核身的相关文档都很简单，出现问题后无从下手，只能慢慢自己摸索解决了，最后写篇文章记录下整个过程，也能帮到后面需要集成这个SDK的朋友们。"}
{"title": "Remax - 使用真正的 React 构建小程序 ", "author": "Rolan", "time": "2019-8-27 00:11", "abstract": "为什么要用 React 来构建小程序 因为 React 是我们最熟悉的技术。 小程序糟糕的 API 设计已经有很多文章吐槽，这里就不再赘述了。再加上现在一大堆小程序平台，每个平台之间又有大大小小的差异，这对于有跨平台需求 ...", "content": "为什么要用 React 来构建小程序\r\n因为 React 是我们最熟悉的技术。\r\n小程序糟糕的 API 设计已经有很多文章吐槽，这里就不再赘述了。再加上现在一大堆小程序平台，每个平台之间又有大大小小的差异，这对于有跨平台需求的小程序来说无异于是一场灾难。\r\nReact 的社区生态体系非常庞大，通过在小程序中引入 React 以及 React Hooks 提供的逻辑抽象能力，我们可以在小程序中直接利用 React 生态体系中大量的技术沉淀（比如：react-use、field-form)。\r\n更完整的 TypeScript 支持。当然你也可以用 TypeScript 去写现有的小程序，但是由于小程序的架构原因，模板层跟逻辑层（也就是 Page）有天然的割裂，即使在逻辑层使用了 TypeScript，在模板层也无法享受类型检查和自动补全带来的便利。引入 React 后，我们的代码全部运行在逻辑层中，可以全程静态类型护航，给你满满的安全感。\r\n现有的方案\r\n目前社区中使用 React 构建小程序的方案大都使用静态编译的方式实现。所谓静态编译，就是使用工具把代码语法分析一遍，把其中的 JSX 部分和逻辑部分抽取出来，分别生产小程序的模板和 Page 定义。\r\n这种方案最大的问题就是会有很多限制，因为语法分析是静态的，所以这些方案都会去限制一些动态的写法。另外正是因为 JavaScript 语言的动态性，要去做语法分析本身就是件很复杂的事情，所以这些方案实现起来往往也非常复杂。\r\n最重要的，静态编译后的你的代码就转换成了小程序代码，运行时其实并没有 React 的存在，你只是用了 React 的写法， 而不是真正的在用 React 做应用。\r\n我们的方案\r\n今年初的时候，@xcodebuild 向大家介绍了如何在小程序中使用 React with Hooks。这是一个非常创新的方案，我们在对这个方案做了完善，并且在线上小程序中得到验证后，正式发布了基于 React 的小程序开发框架：\r\n\r\nwww.remaxjs.org\r\nRemax 让你可以使用真正的 React 去构建小程序，你可以他理解成面向小程序的 React Native。\r\nRemax 原理\r\n首选来看一下小程序的架构（支付宝和微信大同小异）：\r\n\r\n正如上面提到的，小程序架构分为两层，你写的逻辑代码独立运行在一个进程中，每个页面会有自己独立的渲染进程（也就是一个 webview）用来渲染模板。而整个小程序又运行在 APP 容器中（也就是支付宝和微信本身）。逻辑层和视图层之间通过建立一个消息通道来通信。\r\n再来看下 React 的架构：\r\n\r\n最下面一层是 React 本身，上层的 ReactDOM 和 ReactNative 我们称之为「Renderer」。Renderer 跟 React 之间通过 ReactReconciler 连接把元素（也就是通常所说的「虚拟 DOM」）渲染到对应的平台上。而 Remax 就是一个我们实现的 Renderer，它把「虚拟 DOM」渲染到了小程序的视图层上。\r\n\r\n可以看到，我们把 React 和 ReactReconciler 运行在小程序的逻辑层中，并通过 Remax 把生成的「虚拟 DOM」渲染到视图层。从而做到了使用真正的 React 去构建小程序。\r\n最后\r\n正如第一段中提到的，把 React 运行在小程序中可以带来非常大的想象力。小程序本身可以说是一种创新，它把应用分为两层来提高视图层的渲染速度，但是微信从一开始就选择使用私有且落后（起码目前看来是落后的）的技术方案来定义小程序，而后面的追随者为了吸引开发者亦使用了跟微信小程序类似的设计。Remax 希望能打破这个局面，通过开放的生态为开发者带来全新的小程序开发体验。"}
{"title": "基于小程序·云开发构建高考查分小程序丨实战 ", "author": "Rolan", "time": "2019-9-9 00:46", "abstract": "2019高考报名人数达到了 1031 万的新高，作为一名三年前参考高考的准程序猿，赶在高考前，加班加点从零开始做了一款高考查分小程序，算是一名老学长送给学弟学妹们的高考礼。上线仅 1 个月，用户数就突破了 1k，关于 ...", "content": "2019高考报名人数达到了 1031 万的新高，作为一名三年前参考高考的准程序猿，赶在高考前，加班加点从零开始做了一款高考查分小程序，算是一名老学长送给学弟学妹们的高考礼。上线仅 1 个月，用户数就突破了 1k，关于小程序的介绍就不多说了，可以去搜【历年高考分数线查询】体验，今天主要谈谈技术原理和实现细节。数据来源小程序后台共收录近 30w 条数据，包含 2008-2017 年所有重点高校的各个批次的文理分科录取分数线以及 2008-2018 所有采用新课标一卷、新课标二卷、新课标三卷以及部分自主命题省份的从提前批到高职专科批的录取分数线，勉强称得上内容翔实。所有数据均采集自各大院校和各高考相关网站，由于数据量巨大，为提高速度，使用了 concurrent.futures （需要 Python3.5+) 模块里的 ThreadPoolExecutor 来构建线程池来并发执行多任务。数据库采用的是 PgSQL,一款号称世界上最强大的开源数据库产品，所有数据均存在新建的 gaokao 数据库中，其下有两个表，university(院校的录取分）和 province(省份的批次线）university 表说明字段解释name院校名称stu_loc生源地stu_wl文理科pc录取批次year年份score录取平均分province 表说明字段解释year年份stu_loc考生所在地stu_wl文理科pc批次control本批次最低控制线30w 的数据量，多个站点，并发爬取，数据冲突是不可避免地，在执行插入之前，首先过滤掉残缺不全的数据，比如在插入 university 表时某条数据缺少 pc 字段，那么这条记录就应该被舍弃，最严重的是数据重复，我采用的解决办法是：先查询待插入的数据是否已经存在, university 表的主码是（name,stu,stu_wl,pc,year),因为现实约束一个院校只能在一个年份在一个类别一个批次只能有一个录取平均分，如果不存在，才执行最后的插入，并 commit 提交事务。后台搭建在 30w 条数据拿到后，我打算后台采用 Flask+PgSQL 的模式实现，甚至在后台在阿里云服务器部署好，小程序端在开发者工具联调通过之后，小程序上线遇到到一个大麻烦，因为小程序要求线上运行不能通过 ip 地址访问后台，必须通过备案的域名访问，域名购买一个倒不麻烦，只是域名备案比较耗时间，需要一周多时间，而当时距离高考也就不到 5 天，在手足无措之时，无意间看到小程序云开发，关于小程序云开发，官网的介绍是:开发者可以使用云开发开发微信小程序、小游戏，无需搭建服务器，即可使用云端能力。云开发为开发者提供完整的原生云端支持和微信服务支持，弱化后端和运维概念，无需搭建服务器，使用平台提供的 API 进行核心业务开发，即可实现快速上线和迭代，同时这一能力，同开发者已经使用的云服务相互兼容，并不互斥。也就是说，只要把数据导入小程序自带的后台，就能通过小程序平台的 API 访问到这些数据，以前了解过第三方的 LeanCloud云 和 Bomb 云,没想到小程序现在集成了这些功能，不得不佩服一下腾讯。也就是，接下来的后台的工作是主要是导入数据，查询小程序后台可知，后台支持导入 json 或者 csv 格式的数据。于是我就写了个脚本，把数据从本地数据库导出到 json 文件中：import psycopg2\r\nimport json\r\n\r\n# 连接 pgsql 数据库，为保证隐私，密码已隐藏\r\nconn = psycopg2.connect(database=\"gaokao\", user=\"postgres\", password=\"*******\", host=\"127.0.0.1\", port=\"5432\")\r\ncur = conn.cursor()\r\n\r\ncur.execute('select stu_loc,year,stu_wl,pc,control from province')\r\nresult = []\r\nquery_res = cur.fetchall()\r\nfor i in query_res:\r\n    item = {}\r\n    item['stu_loc'] = i[0]\r\n    item['year'] = i[1]\r\n    item['wl'] = i[2]\r\n    item['pc'] = i[3]\r\n    item['score'] = i[4]\r\n    result.append(item)\r\n# indent=2 控制 json 格式的缩进\r\n# ensure_ascii 控制中文的正常显示\r\nwith open(\"province.json\", 'w', encoding=\"utf-8\") as f:\r\n    f.write(json.dumps(result, indent=2, ensure_ascii=False))这里还有有个坑需要说明一下，小程序后台要求的 json 格式和我们平常意义上的 json 格式还有点区别，首先，json 的所有内容不能被 [ 和 ] 包括起来，而且每个被 {} 所包括得数据项之间不能有逗号。选用 notepad++ 打开原来的 json 文件，使用替换功能就能解决，把 [ 和 ] 替换成空格，把 }，替换成 } 即可。修改之后，在小程序后台通过导入该 json 文件，后台搭建就基本完成了。小程序端编写关于小程序端的编写，我主要谈谈两点经验，第一是页面的编写，比如下面这个界面。最开始想实现这样的效果，完全没有思路，最后在从自定义模态弹窗那得到了思路，一开始地区院校这个下拉框对应的布局是隐藏的，在 wxml 文件中通过 hidden=true 控制，一点击 地区/院校 下拉框，就把 hidden 置为 false，如果开始有其他下拉框对应的布局的 hidden 属性是 false 的话，同时要把这些布局的 hidden 属性置为 true 来隐藏其他布局，当然，这里的 true or false 需要在 js 里通过 setData() 动态修改，把修改后的数据从数据层渲染到视图层。第二是关于小程序云开发的原生 Bug,查询后台时一次只能最多查询到 20 条数据，要实现一次得到所有匹配的结果，需要解决两个问题，第一个问题很自然而然就能想到，第一次查到 20 条数据后，第二次跳过前 20 条再取 20 条，第三次跳过前 40 条再取 20 条，以此类推；还有一个更为致命的问题，查询后台的 API 获取结果的回调函数的 异步 的，也就是说，为了保证获得完整数据，第二次查询需要写在第一次查询的回调里，第三次查询需要写在第二次查询的回调里，而且你还不能显式地知道要查询多少次，需要写多少层这样的嵌套，以及烦人的同名变量覆盖问题，这就是所谓的 异步地狱。为了解决这个问题，需要我们编写代码把这个异步方法转成同步的，具体做法是：先在所要添加功能的js页面中导入 runtime.js 文件，同时把runtime.js文件放入相应文件夹；const regeneratorRuntime = require(\"../runtime\");runtime.js 下载地址：https://github.com/inspurer/CampusPunchcard/blob/master/runtime.js同时模仿下例代码完成业务逻辑：// 查询可能较慢，最好加入加载动画​\r\nwx.showLoading({\r\n          title: '加载中',\r\n        })\r\n        const countResult = await db.collection('province').where({\r\n          stu_loc: name,\r\n          pc: pici,\r\n\r\n        }).count()\r\n        const total = countResult.total\r\n        //计算需分几次取\r\n        const batchTimes = Math.ceil(total / MAX_LIMIT)\r\n        // 承载所有读操作的 promise 的数组\r\n        //初次循环获取云端数据库的分次数的promise数组\r\n        for (let i = 0; i < batchTimes; i++) {\r\n          const promise = await db.collection('province').where({\r\n            stu_loc: name,\r\n            pc: pici,\r\n          }).skip(i * MAX_LIMIT).limit(MAX_LIMIT).get()\r\n          //二次循环根据​获取的promise数组的数据长度获取全部数据push到newResult数组中\r\n          for (let j = 0; j < promise.data.length; j++) {\r\n            var item = {};\r\n            item.code = i * MAX_LIMIT + j;\r\n            item.name = promise.data[j].stu_loc;\r\n            item.year = promise.data[j].year;\r\n            item.wl = promise.data[j].wl;\r\n            item.pc = promise.data[j].pc;\r\n            item.score = promise.data[j].score;\r\n            console.table(promise.data)\r\n            newResult.push(item)\r\n          }\r\n        }\r\n        if (newResult.length != 0) {\r\n          that.setData({\r\n            hasdataFlag: true,\r\n            resultData: newResult\r\n          })\r\n        } else {\r\n          that.setData({\r\n            hasdataFlag: false,\r\n            resultData: newResult\r\n          })\r\n        }\r\n        // 隐藏加载动画\r\n        wx.hideLoading()以上就是我本次开发的一些心得体会，欢迎批评指正。课程完整源码https://github.com/TencentCloudBase/Good-practice-tutorial-recommended"}
{"title": "微信小程序实现九宫格图片拖拽 ", "author": "Rolan", "time": "2019-9-18 00:08", "abstract": "前阵子有个需求是实现图片拖拽排序的问题，那会刚接触微信小程序，捣鼓了很多久，也查了很多资料，不过还是很多混乱的地方，最后实现了，所以在此记录一下，希望能帮到其他人，如果有写的不对，或者可以改进的地方， ...", "content": "效果图\r\n\r\n(在真机上的效果就不演示了，是差不多的)\r\n实现思路\r\n布局\r\n在这里运用到了微信小程序的moveable-area和moveable-view两个标签。\r\nmoveable-area是可拖拽的区域，需要设置其宽高。由于图片的大小我是根据屏幕来动态设置的，所以moveable-area的宽度是固定的100%，高度由上传的图片总高度决定，所以一开始的时候，我设置了最小高度。\r\nmoveable-view的宽高跟图片一致，也是动态设置，初始状态是隐藏的，当图片被长按时才会显示。当长按要排序的图片的时候，记录它的url，并赋值给moveable-view的image。\r\n <movable-area class=\"movable-area\" style=\"min-height:{{imageWitdh}}px;height:{{areaHeight}}px\">\r\n      <!--图片上传-->\r\n      <view class=\"image-choose-container\">\r\n        <view class=\"image-item\" style=\"width:{{imageWitdh}}px;height:{{imageWitdh}}px\" wx:for=\"{{images}}\" wx:for-item=\"url\" wx:key=\"url\" data-url=\"{{url}}\" data-index=\"{{index}}\" >\r\n            <image src=\"{{url}}\" mode=\"aspectFill\"></image>\r\n            <view class=\"close\">X</view>\r\n        </view>\r\n          <!--图片上传按钮-->\r\n          <view class=\"add-button\" style=\"width:{{imageWitdh}}px;height:{{imageWitdh}}px\" wx:if=\"{{images.length >= 0 &&images.length < 9}}\">+</view>\r\n          <!--确保flex布局justify-content：space-between最后一行左对齐-->\r\n          <view style=\"width:{{imageWitdh}}px\" class=\"image-item image-item-temp\" wx:if=\"{{images.length%3==1}}\"></view>\r\n      </view>\r\n      \r\n      <movable-view class=\"movable-view\" style=\"width:{{imageWitdh}}px;height:{{imageWitdh}}px\" hidden=\"{{hidden}}\" x=\"{{x}}\" y=\"{{y}}\"  direction=\"all\" damping=\"{{5000}}\" friction=\"{{1}}\">\r\n        <image src=\"{{currentImg}}\" wx:if=\"{{currentImg.length>0}}\"></image>\r\n      </movable-view>\r\n    </movable-area>\r\n复制代码页面初始化时计算宽高的js\r\n// 计算图片宽度\r\n_handleComputedImage:function(e){\r\n    const windowWidth = app.globalData.systemInfo.windowWidth;\r\n    const width = windowWidth - 16;\r\n    const imageWitdh = (width - 16) / 3;\r\n    this.setData({\r\n      imageWitdh\r\n    })\r\n},\r\n复制代码上传图片\r\n在上传图片之后，我们需要改变moveable-area的高度\r\n// 选择图片\r\n  handleChooseImage: function (e) {\r\n    let length = this.data.images.length;\r\n    if (length == 9) {\r\n      wx.showToast({\r\n        title: \"亲，最多只能选择九张图哦~\",\r\n        icon: \"none\",\r\n        duration: 2000\r\n      })\r\n      return false;\r\n    }\r\n    var that = this;\r\n    wx.chooseImage({\r\n      count: 9 - this.data.images.length,\r\n      sizeType: ['compressed'], //可选择原图或压缩后的图片\r\n      sourceType: ['album', 'camera'], //可选择性开放访问相册、相机\r\n      success: res => {\r\n        let images = that.data.images;\r\n        for (let i = 0; i < res.tempFilePaths.length;i++){\r\n          images.push(res.tempFilePaths[i]);\r\n        }\r\n        that.setData({\r\n          images\r\n        },function(){\r\n          //上传完之后更新面积\r\n          that._handleComputedArea();\r\n        });\r\n        \r\n      },\r\n      fail: err => console.log(err)\r\n    })\r\n  },\r\n复制代码更新面积的计算如下,它的高度由.image-choose-container的view决定：\r\n// 计算movable-area的高度\r\n  _handleComputedArea:function(e){\r\n    let that = this;\r\n    wx.createSelectorQuery().selectAll('.image-choose-container').boundingClientRect(function (rect) {\r\n      that.setData({\r\n        areaHeight: rect[0].height\r\n      })\r\n    }).exec()\r\n  },\r\n复制代码p.s. 当删除图片的时候，我们也需要重新计算moveable-area的高度。\r\n长按图片\r\n图片可以拖拽排序的触发机制是长按。\r\n\r\n在长按的时候，我们需要计算每张图片的坐标（这里的坐标不是固定的，当你的页面可以拖动的时候，坐标值是会发生改变）并保存；\r\n记录当前图片在图片数组中的下标、url;\r\n显示moveable-view，并设置其x、y值，将url赋值给其下的子元素。\r\n\r\n// 计算每张图片的坐标\r\n  _handleComputedPoints(e){\r\n    let that = this;\r\n    var query = wx.createSelectorQuery();\r\n    var nodesRef = query.selectAll(\".image-item\");\r\n    nodesRef.fields({\r\n      dataset: true,\r\n      rect: true\r\n    }, (result) => {\r\n      that.setData({\r\n        pointsArr: result\r\n      })\r\n    }).exec()\r\n  },\r\n复制代码 // 长按图片\r\n  handleLongTap:function(e){\r\n    // 计算每张图片的坐标\r\n    this._handleComputedPoints();\r\n    this.setData({\r\n      currentImg: e.currentTarget.dataset.url,\r\n      currentIndex: e.currentTarget.dataset.index,\r\n      hidden: false,\r\n      flag: true,\r\n      x: e.currentTarget.offsetLeft,\r\n      y: e.currentTarget.offsetTop\r\n    })\r\n  },\r\n复制代码此时，长按图片，moveable-view（带有边框）将会出现在该图片之上。\r\n\r\n移动图片\r\n监听moveable-view的catchtouchmove事件，（不使用bindhtouchmove的原因是因为在图片移动的过程中，如果页面是可滑动的，会导致页面页跟着滑动），记录当前手指在页面上的位置e.touches[0].pageX和e.touches[0].pageY。\r\n为了保证手指在移动的过程中，图片能跟着手指一起移动，则moveable-view的x距离是手指的e.touches[0].pageX，而y距离则是e.touches[0].pageX - 滚动条的移动距离-image-choose-container这个元素距离顶部的距离。\r\n\r\n为了保证在移动图片的过程中，图片始终能在手指的中间，还将x,y分别减去图片的宽度。（对比两图，鼠标与moveable-view的位置）\r\n\r\n\r\n  // 移动的过程中\r\n  handleTouchMove:function(e){\r\n    let x = e.touches[0].pageX;\r\n    let y = e.touches[0].pageY;\r\n   // 首先先获得当前image-choose-container距离顶部的距离\r\n    let that = this;\r\n    wx.createSelectorQuery().selectAll('.image-choose-container').boundingClientRect(function (rect) {\r\n      let top = rect[0].top;\r\n      y = y - that.data.scrollTop - top;\r\n      that.setData({\r\n        x: x - that.data.imageWitdh / 2 > 0 ? x - that.data.imageWitdh / 2:0,\r\n        y: y - that.data.imageWitdh / 2 > 0 ? y - that.data.imageWitdh / 2:0,\r\n      })\r\n\r\n    }).exec()\r\n  },\r\n复制代码// 监听滚动\r\n  onPageScroll:function(e){\r\n    this.data.scrollTop = e.scrollTop;\r\n  }\r\n复制代码停止拖拽时\r\n监听moveable-view的bindtouchend事件，计算出当前的x,y值，对比每个图片的下标，得出它移动到哪个位置，更新数组，完毕。\r\n// 移动结束的时候\r\n  handleTouchEnd:function(e){\r\n    if (!this.data.flag) {\r\n      // 非长按情况下\r\n      return;\r\n    }\r\n    let  x = e.changedTouches[0].pageX;\r\n    let y = e.changedTouches[0].pageY - this.data.scrollTop;\r\n    // 每张图片的地址\r\n    const pointsArr = this.data.pointsArr;\r\n    let data = this.data.images;\r\n    for (var j = 0; j < pointsArr.length; j++) {\r\n      const item = pointsArr[j];\r\n      if (x > item.left && x < item.right && y > item.top && y < item.bottom) {\r\n        const endIndex = item.dataset.index;\r\n        const beginIndex = this.data.currentIndex;\r\n        //临时保存移动的目标数据\r\n        let temp = data[beginIndex];\r\n        //将移动目标的下标值替换为被移动目标的下标值\r\n        data[beginIndex] = data[endIndex];\r\n        //将被移动目标的下标值替换为beginIndex\r\n        data[endIndex] = temp;\r\n      }\r\n    }\r\n    this.setData({\r\n      images: data,\r\n      hidden: true,\r\n      flag: false,\r\n      currentImg: ''\r\n    })\r\n  },\r\n复制代码最后附上demo地址：\r\ngithub.com/Middletwo-K…"}
{"title": "小程序登录流程全解析 ", "author": "Rolan", "time": "2019-9-18 00:21", "abstract": "用户登录是一个系统的必备功能。而小程序的登录流程和Web端又有一些不同，主要是要与微信服务器进行通信验证。下面我们就来看下小程序具体的登录流程。 1. 登录流程 小程序可以通过微信官方提供的登录能力方便地获取 ...", "content": "用户登录是一个系统的必备功能。而小程序的登录流程和Web端又有一些不同，主要是要与微信服务器进行通信验证。下面我们就来看下小程序具体的登录流程。\r\n1. 登录流程\r\n小程序可以通过微信官方提供的登录能力方便地获取微信提供的用户身份标识，快速建立小程序内的用户体系。\r\n\r\n2. 登录逻辑：\r\n\r\n\r\n调用 wx.login() 获取 临时登录凭证 code，有效期为 5分钟；（临时登录凭证 code 只能使用一次）\r\n\r\n\r\n将临时 code 传到我们的后端，后端调用 auth.code2Session 接口，换取用户唯一标识 OpenID 和 会话密钥 session_key；（ openid 是用户唯一标识，session_key 能保证当前用户进行会话操作的有效性）\r\n注意：获取 session_key 出于安全性的考虑，要在后端调用。如果我们在前端通过 request 调用此接口，就不可避免的需要将我们小程序的appid 、secret 和服务端下发的 session_key 暴露在外部，会给我们的业务安全带来极大的风险。\r\nsession_key 拥有一定的时效性。用户越久未使用小程序，用户登录态越有可能失效。反之如果用户一直在使用小程序，则用户登录态一直保持有效。具体时效逻辑由微信维护，对开发者透明。开发者需要调用 wx.checkSession 接口检测当前用户登录态是否有效。\r\n\r\n\r\n后端自定义新的密钥并关联返回的 session_key 和 openid，将新的密钥返给前端，前端将其存储在 storage 中。（会话密钥 session_key 是对用户数据进行 加密签名 的密钥。为了应用自身的数据安全，开发者服务器不应该把会话密钥下发到小程序，也不应该对外提供这个密钥，所以要定义新的密钥）。\r\n之所以存在storage中，是因为小程序没有 cookie，相应的后端 set-cookie 在小程序中不起作用。\r\n\r\n\r\n前端发送请求的时候，带着密钥，后端根据密钥识别用户身份，返回数据。\r\n\r\n\r\n3. 遇到的问题\r\n在接口报401错误时，对其做登录处理，登录成功后再次调用接口。这种情况下，多接口并行就会出现问题。\r\n因为多接口都会调 wx.login 获取 code 后再调后端的登录接口，而登录凭证 code 只能使用一次，这时候后端对多接口就会接收到不同的 code，返回的自定义密钥就会有多个，不能保持统一。\r\n\r\n处理的方案是后端在一定时间内对用户自定义登录态做缓存。接口调 wx.login 获取 code 后再调后端的登录接口时，判断后端缓存中有无此用户，如果没有，返回新的密钥，如果缓存中存在此用户并在缓存有效时间内，就查找并返回之前的密钥。\r\n4. 具体代码\r\ncheckSession: 检查登录态是否过期。\r\n通过 wx.login 接口获得的用户登录态拥有一定的时效性。用户越久未使用小程序，用户登录态越有可能失效。反之如果用户一直在使用小程序，则用户登录态一直保持有效。具体时效逻辑由微信维护，对开发者透明。开发者只需要调用 wx.checkSession 接口检测当前用户登录态是否有效。\r\n登录态过期后开发者可以再调用 wx.login 获取新的用户登录态。调用成功说明当前 session_key 未过期，调用失败说明 session_key 已过期。\r\n  checkSession: function () {\r\n    return wx.pro.checkSession().then(res => {\r\n      return Promise.resolve('result1')\r\n    }).catch(err => {\r\n      return this.login()\r\n    })\r\n  },\r\n  \r\n  login: function () {\r\n    return wx.pro.login().then(res => {\r\n      return Promise.resolve(res.code)\r\n    }).then(res => {\r\n      return this.getRequest({\r\n        method: 'POST',\r\n        url: \"***/login\",\r\n        data: {\r\n          code: res\r\n        }\r\n      })\r\n    }).then(res => {\r\n      let Cookie = res && res.header && res.header['Set-Cookie'] || '';\r\n      Cookie = this.getCookie('cookie-key', Cookie)\r\n      wx.setStorageSync('Cookie', Cookie)\r\n      this.globalData.Cookie = Cookie\r\n      return Promise.resolve('result2')\r\n    }).catch(err => {\r\n      console.log('loginErr', err)\r\n    })\r\n  },\r\n  \r\n  getCookie(name, cookie) {\r\n    let arr, reg = new RegExp(\"(^| )\" + name + \"=([^;]*)(;|$)\");\r\n    return (arr = cookie.match(reg)) ? unescape(arr[2]) : null;\r\n  },\r\n  \r\n  getRequest: function (data, tryNum = 1) {\r\n    let header = Object.assign({\r\n      \"Content-Type\": \"application/x-www-form-urlencoded\",\r\n    }, data.header)\r\n    if (data.url !== '**/login') {\r\n      header = Object.assign(header, {\r\n        \"Cookie\": `cookie-key=${this.globalData.Cookie}`\r\n      })\r\n    }\r\n    return new Promise((resolve, reject) => {\r\n      wx.request({\r\n        url: (data.mode !== 'debug' ? Env_config[envObj.env].api : '') + data.url,\r\n        method: data.method || \"GET\",\r\n        header: header,\r\n        data: data.data,\r\n        success: (res) => {\r\n          if (res && res.statusCode === 200) {\r\n            resolve(res)\r\n          } else if (res.statusCode === 401) {\r\n            wx.showToast({\r\n              title: '登录失效，请重新登录',\r\n              icon: 'none',\r\n            })\r\n            if (tryNum > maxTryNum) return null\r\n            return this.login().then(res => {\r\n              return this.getRequest(data, ++tryNum)\r\n            }).then(res => resolve(res))\r\n                .catch(err => {\r\n                  reject(err)\r\n                })\r\n          } else {\r\n            setTimeout(() => {\r\n              wx.showToast({\r\n                title: res && res.data && res.data.msg || '服务异常，请稍后重试',\r\n                icon: 'none'\r\n              })\r\n            }, 0)\r\n            reject(res)\r\n          }\r\n        },\r\n        fail: (err) => {\r\n          setTimeout(() => {\r\n            wx.showToast({\r\n              title: res && res.data && res.data.msg || '服务异常，请稍后重试',\r\n              icon: 'none'\r\n            })\r\n          }, 0)\r\n          reject(err)\r\n        }\r\n      })\r\n    })\r\n  },\r\n复制代码在页面中的用法也很简单：\r\nonLoad: function (options) {\r\n  app.checkSession().then(res => {\r\n    this.otherMethods()\r\n  })\r\n}"}
{"title": "微信小程序之下载(下载文件tempFilePath后缀unknown) ", "author": "Rolan", "time": "2019-9-18 00:36", "abstract": "最近有用到微信小程序的downloadFile接口，但是在真机上出现了文件后缀为unknown，导致文件保存失败，这里记录下", "content": "1.下载文件使用downloadFile下载API/* 直接这样写的话，会出现下载文件后缀名为unknown的情况 */\r\nwx.downloadFile({\r\n  url: '',\r\n  success (res) {\r\n    console.log(res.filePath);\r\n  }\r\n})改进后的下载保存/* 使用时间戳为下载后的文件的名字 */\r\nlet fileName = new Date().valueOf();\r\nwx.downloadFile({\r\n  /* url 为要下载的文件链接 */\r\n  url: '',\r\n  /* filePath指定文件下载后存储的路径，wx.env.USER_DATA_PATH */\r\n  filePath: wx.env.USER_DATA_PATH + '/' + fileName + '.mp4', \r\n  success: res => {\r\n    let filePath = res.filePath;\r\n    wx.saveVideoToPhotosAlbum({\r\n      filePath,\r\n      success: file => {\r\n        wx.hideLoading();\r\n        /* 删除缓存 */\r\n        let fileMgr = wx.getFileSystemManager();\r\n        fileMgr.unlink({\r\n           filePath: wx.env.USER_DATA_PATH + '/' + fileName + '.mp4',\r\n           success: function (r) {\r\n\r\n           },\r\n        })\r\n     },\r\n     fail: err => {\r\n        wx.hideLoading();\r\n        /* 拒绝授权时显示 */\r\n        if (err.errMsg === 'saveVideoToPhotosAlbum:fail auth deny') {\r\n          wx.showModal({\r\n            title: '提示',\r\n            content: '需要您授权保存相册',\r\n            showCancel: false,\r\n            success: data => {\r\n              /* 打开权限设置 */\r\n              wx.openSetting({\r\n                success: setting => {\r\n                  if (setting.authSetting['scope.writePhotosAlbum']) {\r\n                    wx.showModal({\r\n                      title: '提示',\r\n                      content: '获取权限成功,再次点击下载即可保存',\r\n                      showCancel: false,\r\n                    })\r\n                  } else {\r\n                    wx.showModal({\r\n                      title: '提示',\r\n                      content: '获取权限失败，将无法保存到相册哦',\r\n                      showCancel: false,\r\n                    })\r\n                  }\r\n                },\r\n              })\r\n            }\r\n          })\r\n        }\r\n      },\r\n  },\r\n  fail: err => {\r\n    wx.hideLoading();\r\n    if (err.errMsg == 'downloadFile:fail createDownloadTask:fail url not in domain list') {\r\n        wx.showToast({\r\n          title: '服务器错误，请联系相关管理员',\r\n          icon: 'none'\r\n        })\r\n     }\r\n  },\r\n  complete: () => {\r\n    wx.hideLoading();\r\n  }\r\n})2.下载图片下载图片的步骤和上面是一样的，就是在保存的时候，api使用的不一样 wx.saveImageToPhotosAlbum({\r\n    filePath: '',\r\n    success: () => {}\r\n})"}
{"title": "小程序Ticker倒计时最佳实践 ", "author": "Rolan", "time": "2019-9-20 00:22", "abstract": "Hello 小伙伴们，如果觉得本文还不错，记得给个 star ， 小伙伴们的 star 是我持续更新的动力！GitHub 地址 一. 什么是ticker？ tick本来的意思是钟表的滴答声。Ticker类为游戏开发提供了一个主要的定时类。它主要的 ...", "content": "Hello 小伙伴们，如果觉得本文还不错，记得给个 star ， 小伙伴们的 star 是我持续更新的动力！GitHub 地址\r\n一. 什么是ticker？\r\ntick本来的意思是钟表的滴答声。Ticker类为游戏开发提供了一个主要的定时类。它主要的目的就是把stage渲染的工作集中起来，也就是说定时调用stage.update()这个方法。Ticker设置的频率也就是游戏的帧数了。\r\n我们把Ticker应用到小程序开发中，频率设置为1s。\r\nTicker的使用如下，初始化Ticker对象，添加侦听tick事件，启动ticker。\r\nconst ticker = new Ticker()\r\n// 参数为Object类型，必须有tick方法\r\nticker.addTick({\r\n    tick: (delta) => {\r\n    \t...\r\n    }\r\n})\r\nticker.start()\r\n复制代码这里不细说Ticker的实现，详情请看Ticker.js源码。\r\n二. 小程序倒计时的烦恼\r\n假如我们都在页面onShow设置setTimeout。\r\n1、onHide取消clearTimeout。假如首页有个倒计时在倒数100S，进入二级页面后，触发onHide，取消clearTimeout。过了10S返回首页，又重新启动setTimeout，那么应该是从100S还是90S开始倒数呢？\r\n那肯定是90S开始呀，可是setTimeout都停了，怎么记录到过去了10S呢？\r\n2、onUnload 取消clearTimeout。onHide之后，其实倒计时还在后台执行，setData也在重新渲染。如果有多级页面，无疑是非常浪费性能。\r\n三. Ticker实现countdown解决方案\r\n在Page的生命周期函数中，添加tick处理。\r\nimport ticker from './utils/ticker'\r\n\r\nPage({\r\n\tcountdown: 100,\r\n\t// 添加当前页面对象到ticker队列\r\n\tonLoad () {\r\n\t\tticker.addTick(this)\r\n\t},\r\n\t// 恢复当前页面对象tick\r\n\tonShow () {\r\n\t\tticker.resume(this)\r\n\t},\r\n\t// 暂停当前页面对象tick\r\n\tonHide () {\r\n\t\tticker.pause(this)\r\n\t},\r\n\t// 移除当前页面对象tick从ticker队列\r\n\tonUnload () {\r\n\t\tticker.removeTick(this)\r\n\t},\r\n\t// 需要计时的页面添加tick方法\r\n\ttick (delta) {\r\n\t\tcountdown -= delta\r\n\t\tthis.setData({\r\n\t\t\tcountdown\r\n\t\t})\r\n\t}\r\n})\r\n复制代码统一处理Page的tick\r\n每个需要用ticker的页面，都需要在各自的生命周期函数里面添加对应的操作。重复的工作交给代码，来重写Page构造函数。interceptor.js\r\n// 生命周期函数集合\r\nconst Interceptor = {\r\n    onLoad: [], onShow: [], onHide: [], onUnload: []\r\n}\r\n\r\n/**\r\n * 组合函数，依次执行\r\n * @param  {...Function} args 被组合的函数\r\n */\r\nfunction compose(interceptorList, sourceMethod){\r\n    return function () {\r\n        [...interceptorList, sourceMethod].forEach( fn => {\r\n            typeof fn === 'function' && fn.call(this, arguments)\r\n        });\r\n    }\r\n}\r\n\r\n/**\r\n * 小程序Page方法的替代实现\r\n */\r\nconst wxPage = Page\r\n\r\n/**\r\n * 重写Page构造函数\r\n * @param pageObject - 传入的页面对象\r\n */\r\nPage = function (pageObject) {\r\n    Object.keys(Interceptor).forEach((keyName) => {\r\n        const sourceMethod = pageObject[keyName]\r\n        pageObject[keyName] = compose(Interceptor[keyName], sourceMethod)\r\n    })\r\n    return wxPage(pageObject)\r\n}\r\n\r\n/**\r\n * 增加对Page生命周期方法的拦截器\r\n * @param methodName\r\n * @param handler\r\n */\r\nexport function addInterceptor (methodName, handler) {\r\n    Interceptor[methodName] && Interceptor[methodName].push(handler)\r\n}\r\n复制代码小程序入口文件app.js，给页面生命周期函数全局注入ticker对应的方法。\r\nimport * as Interceptor from './utils/interceptor'\r\nimport ticker from './utils/ticker'\r\n\r\nInterceptor.addInterceptor('onLoad', function () {\r\n    ticker.addTick(this)\r\n})\r\n\r\nInterceptor.addInterceptor('onShow', function () {\r\n    ticker.resume(this)\r\n})\r\n\r\nInterceptor.addInterceptor('onHide', function () {\r\n    ticker.pause(this)\r\n})\r\n\r\nInterceptor.addInterceptor('onUnload', function () {\r\n    ticker.removeTick(this)\r\n})\r\n\r\nApp({\r\n    onLaunch () {\r\n        \r\n    }\r\n})\r\n复制代码页面只需要添加tick方法，利用delta计算倒数时间，无需操作ticker逻辑。page.js：\r\nimport formatTime from '../../utils/formatTime'\r\nPage({\r\n    countdown: 1000,\r\n    data: {\r\n        countdownStr: ''\r\n    },\r\n    tick (delta) {\r\n        console.log('index tick')\r\n        let countdownStr = formatTime(this.countdown -= delta)\r\n        this.setData({\r\n            countdownStr\r\n        })\r\n    }\r\n});\r\n复制代码done\r\n\r\nGithub: github.com/songdy/todo…"}
{"title": "两天撸两个天气小程序 ", "author": "Rolan", "time": "2019-9-20 00:25", "abstract": "经过最近两年多的发展，小程序的地位也逐渐越来越高了，各个平台前赴后继做了自家的小程序平台，随着市场的需求越来愈多，我们开发各平台的小程序的激情也随（被）之（逼）高（无）涨（奈）。选择uniapp来开发。uni- ...", "content": "经过最近两年多的发展，小程序的地位也逐渐越来越高了，各个平台前赴后继做了自家的小程序平台，随着市场的需求越来愈多，我们开发各平台的小程序的激情也随（被）之（逼）高（无）涨（奈）。选择uniapp来开发。uni-app 是一个使用 Vue.js 开发所有前端应用的框架，开发者编写一套代码，可发布到iOS、Android、H5、以及各种小程序（微信/支付宝/百度/头条/QQ/钉钉）等多个平台。即使不跨端，uni-app同时也是更好的小程序开发框架。来自官方。喜欢taro， wepy，mpvue的朋友也莫喷我，大家各有所好，大家开心就好。【智行天气】小程序效果图1、获取位置信息在定位功能中，本程序用到腾讯地图的api 以及 腾讯天气的api接口，需要到官网中注册开发者账号，通过注册后得到的appKey来请求我们需要的数据，详细注册步骤请自行度娘由于需要用到定位功能，uniapp的getLocation方法获取到的是当前位置的坐标，然后对应腾讯地图具体城市uni.getLocation({\r\n    // #ifdef MP-WEIXIN\r\n    type: 'wgs84',\r\n    // #endif\r\n    async success (res) {\r\n        const {latitude, longitude} = res\r\n        const result = await that.ajax({url: 'https://apis.map.qq.com/ws/geocoder/v1', data: {\r\n            location: `${latitude},${longitude}`,\r\n            key: ''\r\n        }})\r\n        let {province, city, district} = result.result.address_component\r\n        that.getData(province, city, district)\r\n    },\r\n    fail(){\r\n        uni.showModal({\r\n          content: '检测到您没打开定位权限，是否去设置打开？',\r\n          confirmText: \"确认\",\r\n          cancelText: \"取消\",\r\n          success: function (res) {\r\n            if (res.confirm) {\r\n              // #ifdef MP-WEIXIN\r\n              wx.openSetting({\r\n                success: (res) => {\r\n                    that.getIn()\r\n                }\r\n              })\r\n              // #endif\r\n              // #ifdef MP-ALIPAY\r\n              my.openSetting({\r\n                 success: (res) => {\r\n                    that.getIn()\r\n                 }\r\n              })\r\n              // #endif\r\n            }\r\n          }\r\n        });\r\n    }\r\n})2、查询天气得到城市名后，再用城市名查询天气的接口，得到未来几天的天气预报。天气接口使用腾讯天气接口api。在小程序中使用前，要在小程序设置界面，开发设置中添加request合法域名。methods: {\r\n    async getData(province, city, district){\r\n        const that = this\r\n        const data = await that.ajax({url: 'https://wis.qq.com/weather/common', data: {\r\n            source: 'xw',\r\n            weather_type: 'observe|alarm|air|forecast_1h|forecast_24h|index|limit|tips|rise',\r\n            province: province,\r\n            city: city,\r\n            county: district\r\n        }})\r\n        that.region = [province, city, district]\r\n        if(data.status != 200){\r\n            uni.showToast({\r\n                title: result.message,\r\n                icon: 'none'\r\n            });\r\n            return false;\r\n        }\r\n        if(!data.data.air.aqi_name){\r\n            uni.showToast({\r\n                title: '暂无该地区的天气信息',\r\n                icon: 'none'\r\n            });\r\n            return false;\r\n        }\r\n        that.data = data.data\r\n    }\r\n}3、小程序界面由于没有什么审美，缺乏想象力，参考腾讯天气的界面来做的。功能十分简单，查看当前地区的天气和切换其他地区的天气，查看最近24小时的天气情况以及最近6天的天气情况，展示今天的农历时间。4、插件使用想快速完成小程序的搭建，里面的折线图采用的 uchart.js ,因为可以兼容支付宝小程序和微信小程序，农历查询也是采用的插件 calendar.js折线图在支付宝小程序中会有模糊的问题，需要做兼容处理<template>\r\n<!-- #ifdef MP-ALIPAY -->\r\n<canvas canvas-id=\"canvas\" id=\"canvas\" width=\"750\" height=\"240\" style=\"width:750rpx;height:240rpx;\" class=\"canvas\">\r\n</canvas>\r\n<!-- #endif -->\r\n<!-- #ifdef MP-WEIXIN -->\r\n<canvas canvas-id=\"canvas\" id=\"canvas\" class=\"canvas\">\r\n</canvas>\r\n<!-- #endif -->\r\n</template>\r\n\r\n<script>\r\nvar wxCharts = require('../../utils/chart.js');\r\nlineChart = new wxCharts({\r\n    $this: this,\r\n    canvasId: 'canvas',\r\n    type: 'line',\r\n    categories: ['', '', '', '', '' ,''],\r\n    colors: ['#ffad35', '#4fc3f7'],\r\n    background: '#fff',\r\n    animation: true,\r\n    series: [{\r\n        name: '',\r\n        data: that.max,\r\n        format: function (val, name) {\r\n            return val + '°';\r\n        }\r\n    }, {\r\n        name: '',\r\n        data: that.min,\r\n        format: function (val, name) {\r\n            return val + '°';\r\n        }\r\n    }],\r\n    xAxis: {\r\n        disableGrid: true,\r\n        disabled: true,\r\n        axisLine: false\r\n    },\r\n    yAxis: {\r\n        max: Math.max.apply(Math, that.max) * 1 + 0.1,\r\n        disabled: true,\r\n        disableGrid: true,\r\n    },\r\n    legend:{ \r\n        show: false \r\n    },\r\n    // #ifdef MP-ALIPAY\r\n    pixelRatio: that.pixelRatio, // 解决支付宝模糊问题\r\n    // #endif\r\n    width: that.cWidth,\r\n    height: that.cHeight\r\n});\r\n</script>微信小程序有城市选择组件，支付宝的没有可以直接使用的城市组件，uniapp官方介绍:支持安装 mpvue 组件，但npm方式不支持小程序自定义组件（如 wxml格式的vant-weapp）,找到一款支付宝可以使用的城市插件： mpvue-citypicker ,城市选择组件<template>\r\n    <view class=\"txt-location\" @tap=\"showCityPicker\">\r\n        <view class=\"icon\"></view>\r\n        <block v-if=\"region.length\">{{region[0]}}{{region[1]}}{{region[2]}}</block>\r\n        <block v-else>选择城市</block>\r\n        <!-- #ifdef MP-WEIXIN -->\r\n        <picker class=\"city\" mode=\"region\" @change=\"handleChange\" :value=\"region\">\r\n            <view class=\"picker\">\r\n                当前选择：{{region[0]}}，{{region[1]}}，{{region[2]}}\r\n            </view>\r\n         </picker>\r\n        <!-- #endif -->\r\n    </view>\r\n    <mpvue-city-picker ref=\"mpvueCityPicker\" :pickerValueDefault=\"pickerValueDefault\" @onConfirm=\"onConfirm\"></mpvue-city-picker>\r\n</template>\r\n\r\n<script>\r\nimport mpvueCityPicker from 'mpvue-citypicker';\r\nexport default {\r\n  data() {\r\n    return {\r\n      region: [],\r\n      pickerValueDefault: [0, 0, 1]\r\n    };\r\n  },\r\n  components: {\r\n    mpvueCityPicker\r\n  },\r\n  methods: {\r\n    showCityPicker() {\r\n        // #ifdef MP-ALIPAY\r\n        this.$refs.mpvueCityPicker.show()\r\n        // #endif\r\n    },\r\n    onConfirm(e) {\r\n        if(e.label){\r\n            this.region = e.label.split('-')\r\n            this.getData(this.region[0], this.region[1], this.region[2])\r\n        }\r\n    },\r\n    handleChange(e) {\r\n        this.region = e.detail.value\r\n        this.getData(this.region[0], this.region[1], this.region[2])\r\n    }\r\n  }\r\n};\r\n</script>总结界面很快就搭建完成，提供了较为完整的组件以及各种API2天气接口查询的腾讯天气的，需要做过滤处理才能使用，某些地区查询天气没有返回需要友情提示处理第一次做支付宝小程序遇到的坑不少，例如图表模糊，城市选择组件需要自己做，消息提示框uni.showToast使用时需要兼容，支付宝不能使用duration字段，获取位置uni.getLocation使用时也需要兼容，支付宝不能使用type字段等。程序的提交审核比较快，我的大概是用了一天的时间就申请好了。但是支付宝审核比较慢后续将代码放到 https://github.com/galan99"}
{"title": "微信小程序wxparse解析iframe中视频办法 ", "author": "Rolan", "time": "2019-9-23 00:08", "abstract": "微信小程序里面，对于富文本标签，我们通常使用wxparse这个插件来进行解析，可以说非常的方便。但是今天在使用的时候，遇到了iframe中是视频地址的问题。如果是标准的视频标签。wxparse是可以正常解析的，但是如果是 ...", "content": "微信小程序里面，对于富文本标签，我们通常使用wxparse这个插件来进行解析，可以说非常的方便。但是今天在使用的时候，遇到了iframe中是视频地址的问题。如果是标准的视频标签。wxparse是可以正常解析的，但是如果是下面这样的形式的话，小程序是无法显示视频的。<iframe class=\"ql-video\" frameborder=\"0\" allowfullscreen=\"true\" src=\"\t” _src=”https://lj-1251274653.cos.ap-chengdu.myqcloud.com/ljfl.mp4\">”>https://lj-1251274653.cos.ap-chengdu.myqcloud.com/ljfl.mp4\">问题的原因就是wxparse没有对iframe标签进行解析匹配，我们需要自己修改wxparse来使它可以解析iframe标签。解决过程如下：修改wxparse中的html2json.js文件，添加对iframe标签的解析。function html2json(html, bindName) {\r\n   \r\n    HTMLParser(html, {\r\n        start: function (tag, attrs, unary) {\r\n           ...\r\n            //对img添加额外数据\r\n            if (node.tag === 'img') {\r\n                node.imgIndex = results.images.length;\r\n                var imgUrl = node.attr.src;\r\n                if(!imgUrl) {\r\n                  return\r\n                }\r\n                if (imgUrl[0] == '') {\r\n                    imgUrl.splice(0, 1);\r\n                }\r\n                imgUrl = wxDiscode.urlToHttpUrl(imgUrl, __placeImgeUrlHttps);\r\n                node.attr.src = imgUrl;\r\n                node.from = bindName;\r\n                results.images.push(node);\r\n                results.imageUrls.push(imgUrl);\r\n            }\r\n           \r\n            // 处理iframe的地址\r\n            if(node.tag === 'iframe') {\r\n                \r\n                node.src= node.attr.src;\r\n            }\r\n        .....};2.\t在wxParse.wxml添加iframe视频模板<template name=\"wxPraseIframe\">\r\n<video id=\"myVideo\" src=\"{{item.src}}\"  enable-danmu danmu-btn controls></video>\r\n</template>3.在wxParse.wxml中，对循环模板添加处理。<!--循环模版-->\r\n<template name=\"wxParse0\">\r\n<!--<template is=\"wxParse1\" data=\"{{item}}\" />-->\r\n<!--判断是否是标签节点-->\r\n<block wx:if=\"{{item.node == 'element'}}\">\r\n<block wx:if=\"{{item.tag == 'button'}}\">\r\n<button type=\"default\" size=\"mini\">\r\n<block wx:for=\"{{item.nodes}}\" wx:for-item=\"item\" wx:key=\"\">\r\n<template is=\"wxParse1\" data=\"{{item}}\" />\r\n</block>\r\n</button>\r\n</block>\r\n<!--li类型-->\r\n<block wx:elif=\"{{item.tag == 'li'}}\">\r\n<view class=\"{{item.classStr}} wxParse-li\" style=\"{{item.styleStr}}\">\r\n<view class=\"{{item.classStr}} wxParse-li-inner\">\r\n<view class=\"{{item.classStr}} wxParse-li-text\">\r\n<view class=\"{{item.classStr}} wxParse-li-circle\"></view>\r\n</view>\r\n<view class=\"{{item.classStr}} wxParse-li-text\">\r\n<block wx:for=\"{{item.nodes}}\" wx:for-item=\"item\" wx:key=\"\">\r\n<template is=\"wxParse1\" data=\"{{item}}\" />\r\n</block>\r\n</view>\r\n</view>\r\n</view>\r\n</block>\r\n<!--video类型-->\r\n<block wx:elif=\"{{item.tag == 'video'}}\">\r\n<template is=\"wxParseVideo\" data=\"{{item}}\" />\r\n</block>\r\n<!--iframe插件（这个是我们添加的）-->\r\n<block wx:elif=\"{{item.tag == 'iframe'}}\">\r\n<template is=\"wxPraseIframe\" data=\"{{item}}\" />\r\n</block>需要注意的是，循环模板可能会有很多个，比如<template name=\"wxParse1\"><template name=\"wxParse2\">我们最好都添加上iframe的模板解析"}
{"title": "叮点跑腿小程序部署教程 ", "author": "Rolan", "time": "2019-9-23 00:13", "abstract": "|--server //服务端目录 |--client //后台客户端目录 |--wxapp //微信小程序项目目录 |--ddrun.sql //数据库文件 复制代码准备工作1.微信小程序账号 (需要企业版+微信认证)2.微信商户号 需要支付证书 用做退款功能3. ...", "content": "|--server //服务端目录\r\n|--client //后台客户端目录\r\n|--wxapp //微信小程序项目目录\r\n|--ddrun.sql //数据库文件\r\n复制代码准备工作1.微信小程序账号 (需要企业版+微信认证)2.微信商户号 需要支付证书 用做退款功能3.如需公众号提醒功能 需要认证过的服务号4.阿里云短信相关的东西5.腾讯地图API key拥有以上全部内容，即可进行安装部署操作。一、安装环境方案一、自行手动安装git、nodejs、mysql、pm2管理器方案二、安装“宝塔面板”，然后进入\"软件管理\"安装nginx、pm2管理器(自带nodejs)、mysql。若安装过程中出现报错问题，请检查软件版本问题。请参考作者的服务器环境：mysql5.5 | node v8.9.1二、部署服务端请先将数据库文件导入到数据库。数据库编码为“utf8mb4”1、修改pm2.json文件文件目录：server/pm2.jsonname为项目名，cwd为项目再服务器的根目录，其他无需更改。{\r\n  \"apps\": [{\r\n    \"name\": \"runing_demo\",   //项目名称\r\n    \"script\": \"production.js\",\r\n    \"cwd\": \"/www/wwwroot/nodeproject/runing_demo\",   //服务器项目根目录\r\n    \"exec_mode\": \"fork\",\r\n    \"max_memory_restart\": \"1G\",\r\n    \"autorestart\": true,\r\n    \"node_args\": [],\r\n    \"args\": [],\r\n    \"env\": {\r\n    }\r\n  }]\r\n}\r\n复制代码2、修改配置文件adapter.js文件目录：server/src/config/adapter.js...省略以上配置...\r\n/**\r\n * model adapter config\r\n * @type {Object}\r\n */\r\nexports.model = {\r\n  type: 'mysql',\r\n  common: {\r\n    logConnect: isDev,\r\n    logSql: isDev,\r\n    logger: msg => think.logger.info(msg)\r\n  },\r\n  mysql: {\r\n    handle: mysql,\r\n    database: 'ddrun_demo',  //数据库名称\r\n    prefix: 'erd_',  \r\n    encoding: 'utf8',  \r\n    host: '127.0.0.1',  //地址\r\n    port: '',    //默认3306\r\n    user: 'root', //用户名\r\n    password: 'root', //密码\r\n    dateStrings: true\r\n  }\r\n};\r\n...省略以下配置...\r\n复制代码3、安装依赖#1.进入项目目录\r\n$ cd server \r\n#2.安装依赖\r\n$ npm install\r\n复制代码4、运行项目#线上运行\r\n$ npm run compile\r\n$ pm2 start pm2.json\r\n\r\n#本地运行\r\n$ node development.js\r\n复制代码项目默认端扣为8360。服务端默认访问地址为：http://x.x.x.x:8360/建议使用nginx做域名反向代理三、部署后台客户端1、修改apiurl.js文件文件目录：client/public/js/apiurl.jsexport default 'http://x.x.x.x:8360/' //改为服务端访问地址\r\n复制代码2、安装依赖#1.进入项目目录\r\n$ cd client\r\n#2.安装依赖\r\n$ npm install\r\n复制代码3、运行项目#线上运行\r\n$ pm2 start npm -- run serve\r\n\r\n#本地运行\r\n$ npm run serve\r\n复制代码项目默认端扣为8361。服务端默认访问地址为：http://x.x.x.x:8361/默认登录账号：admin 密码：qwe147258建议使用nginx做域名反向代理开源地址：https://gitee.com/yaozy717/ddrun"}
